<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Catálogo de MiniApps</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Estilos customizados para o Tailwind e fontes */
    body { font-family: 'Inter', sans-serif; background-color: #f7f9fc; }
    .ma-card { transition: transform 0.2s, box-shadow 0.2s; }
    .ma-card:hover { transform: translateY(-3px); box-shadow: 0 10px 15px rgba(0,0,0,0.1); }
    .loading-spinner { border-top-color: #3b82f6; }
    
    /* Esconde a barra de rolagem horizontal em dispositivos menores, se necessário */
    .catalog-container { overflow-x: hidden; }
    
    /* Ajustes responsivos para a lista de cards */
    #catalog-list {
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    }

    body[data-theme="dark"] { background-color: #020617; color: #e2e8f0; }
    body[data-theme="dark"] header { background-color: #0f172a; }
    body[data-theme="dark"] .bg-white { background-color: #0f172a !important; }
    body[data-theme="dark"] .ma-card { background-color: #0f172a !important; box-shadow: 0 10px 30px rgba(15, 23, 42, 0.4); }
    body[data-theme="dark"] .ma-card:hover { box-shadow: 0 12px 32px rgba(15, 23, 42, 0.6); }
    body[data-theme="dark"] .text-gray-900 { color: #f8fafc !important; }
    body[data-theme="dark"] .text-gray-700,
    body[data-theme="dark"] .text-gray-600,
    body[data-theme="dark"] .text-gray-500 { color: #cbd5f5 !important; }
    body[data-theme="dark"] .border-gray-100,
    body[data-theme="dark"] .border-gray-200,
    body[data-theme="dark"] .border-gray-300 { border-color: #1e293b !important; }
    body[data-theme="dark"] .bg-gray-50 { background-color: #1e293b !important; }
    body[data-theme="dark"] .text-indigo-600,
    body[data-theme="dark"] .text-indigo-800 { color: #93c5fd !important; }
    body[data-theme="dark"] .bg-indigo-100 { background-color: rgba(37, 99, 235, 0.35) !important; color: #c7d2fe !important; }
    body[data-theme="dark"] .bg-green-100 { background-color: rgba(22, 163, 74, 0.3) !important; color: #bbf7d0 !important; }
    body[data-theme="dark"] .bg-yellow-100 { background-color: rgba(217, 119, 6, 0.3) !important; color: #fde68a !important; }
    body[data-theme="dark"] .bg-blue-100 { background-color: rgba(37, 99, 235, 0.35) !important; color: #bfdbfe !important; }
    body[data-theme="dark"] input,
    body[data-theme="dark"] select { background-color: #0f172a; color: #f8fafc; border-color: #1e293b !important; }
    body[data-theme="dark"] input::placeholder { color: #94a3b8; }
    body[data-theme="dark"] a { color: #93c5fd; }
    body[data-theme="dark"] .loading-spinner { border-color: #1e293b; border-top-color: #38bdf8; }
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body class="p-4 md:p-8 catalog-container">

  <div class="max-w-7xl mx-auto">
    
    <!-- Cabeçalho Limpo (Apenas o Título do Catálogo) -->
    <header class="bg-white p-6 rounded-xl shadow-lg mb-8">
      <h1 id="catalogTitle" class="text-3xl font-bold text-gray-900 mb-2">Seu Catálogo de MiniApps</h1>
      <p id="catalogSubtitle" class="text-gray-600 mb-4">Explore os aplicativos disponíveis para uso.</p>
      
      <!-- Barra de Pesquisa e Filtro (Adicionada para usabilidade) -->
      <div class="flex flex-col sm:flex-row gap-4">
        <input 
            type="text" 
            id="searchBar" 
            placeholder="Buscar por nome, categoria ou descrição..."
            class="p-3 border border-gray-300 rounded-lg w-full sm:flex-1 focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
        />
        <select id="categoryFilter" class="p-3 border border-gray-300 rounded-lg w-full sm:w-48 bg-white focus:ring-indigo-500 focus:border-indigo-500 transition duration-150">
            <option value="" data-default-option>Todas as Categorias</option>
            <!-- Opções de categoria serão preenchidas via JS -->
        </select>
      </div>
      
      <p id="status-message" class="mt-4 text-sm text-gray-500">Inicializando...</p>
    </header>
    
    <!-- Seção do Catálogo -->
    <div id="catalog-list" class="grid gap-6">
      <!-- Cards do Catálogo serão injetados aqui -->
      <div class="col-span-full flex justify-center items-center h-40">
        <div class="loading-spinner w-8 h-8 border-4 border-gray-200 rounded-full animate-spin"></div>
      </div>
    </div>

  </div>

  <script type="module">
    import { DEFAULT_LOCALE, getCatalogMessages, getDirection } from "../js/i18n.js";

    const statusMessage = document.getElementById('status-message');
    const catalogList = document.getElementById('catalog-list');
    const searchBar = document.getElementById('searchBar');
    const categoryFilter = document.getElementById('categoryFilter');
    const catalogTitleEl = document.getElementById('catalogTitle');
    const catalogSubtitleEl = document.getElementById('catalogSubtitle');

    let currentLocale = DEFAULT_LOCALE;
    let catalogMessages = getCatalogMessages(currentLocale);
    let fullCatalogData = [];
    let currentStatusKey = null;
    let currentStatusContext = {};
    let currentStatusFallback = '';
    let currentStatusExtras = null;
    let currentUserRole = null;
    let authGuardsDisabled = false;
    const LOCAL_STORAGE_KEY = 'miniapp-catalog.admin.activeItems';

    const filterOptions = {
      searchText: '',
      category: '',
    };

    const ROLE_PRIORITY = {
      admin: 3,
      operador: 2,
      leitor: 1,
    };

    const ROLE_ALIASES = {
      administrador: 'admin',
      administrator: 'admin',
      admin: 'admin',
      operator: 'operador',
      operador: 'operador',
      operadora: 'operador',
      reader: 'leitor',
      leitor: 'leitor',
      leitura: 'leitor',
      viewer: 'leitor',
    };

    function formatTemplate(template, context = {}) {
      if (typeof template !== 'string') {
        return '';
      }
      return template.replace(/\{\{(.*?)\}\}/g, (_, rawKey) => {
        const trimmed = rawKey.trim();
        return Object.prototype.hasOwnProperty.call(context, trimmed) ? context[trimmed] : '';
      });
    }

    function normalizeRole(role) {
      if (typeof role !== 'string') {
        return '';
      }
      const normalized = role.trim().toLowerCase();
      if (!normalized) {
        return '';
      }
      if (Object.prototype.hasOwnProperty.call(ROLE_PRIORITY, normalized)) {
        return normalized;
      }
      return ROLE_ALIASES[normalized] || '';
    }

    function roleSatisfies(requiredRole, userRole) {
      if (authGuardsDisabled) {
        return true;
      }
      if (!requiredRole) {
        return true;
      }
      const requiredRoles = Array.isArray(requiredRole)
        ? requiredRole
        : String(requiredRole).split(',');
      const normalizedUser = normalizeRole(userRole);
      if (!normalizedUser) {
        return false;
      }
      const userRank = ROLE_PRIORITY[normalizedUser] || 0;
      return requiredRoles.some((role) => {
        const normalizedRequired = normalizeRole(role);
        if (!normalizedRequired) {
          return true;
        }
        return userRank >= (ROLE_PRIORITY[normalizedRequired] || 0);
      });
    }

    function formatRoleLabel(role) {
      const normalized = normalizeRole(role);
      if (!normalized) {
        return 'adequado';
      }
      if (normalized === 'admin') {
        return 'administrador';
      }
      return normalized;
    }

    function translateStatus(key, fallback = '', context = {}) {
      if (!key) {
        return typeof fallback === 'string' ? fallback : '';
      }
      const template = catalogMessages?.status?.[key];
      if (typeof template === 'string') {
        return formatTemplate(template, context);
      }
      return typeof fallback === 'string' ? fallback : '';
    }

    function showStatus(key, fallback = '', type = 'info', context = {}) {
      if (!statusMessage) return;
      const resolvedMessage = key ? translateStatus(key, fallback, context) : fallback;
      statusMessage.textContent = resolvedMessage;
      statusMessage.className = 'mt-4 text-sm';
      switch (type) {
        case 'success':
          statusMessage.classList.add('text-green-600');
          break;
        case 'error':
          statusMessage.classList.add('text-red-600');
          break;
        case 'warning':
          statusMessage.classList.add('text-yellow-600');
          break;
        default:
          statusMessage.classList.add('text-gray-500');
          break;
      }
      currentStatusKey = key;
      currentStatusContext = key ? { ...context } : {};
      currentStatusFallback = typeof fallback === 'string' ? fallback : '';
      currentStatusExtras = null;
    }

    function mergeCatalogEntries(primary = [], extras = []) {
      const merged = new Map();

      const push = (item, prefix) => {
        if (!item) {
          return;
        }
        const rawKey = typeof item.id === 'string' && item.id.trim()
          ? item.id.trim()
          : typeof item.url === 'string' && item.url.trim()
            ? item.url.trim()
            : null;
        const key = rawKey || `${prefix}-${merged.size}`;
        if (merged.has(key)) {
          merged.set(key, { ...merged.get(key), ...item });
        } else {
          merged.set(key, item);
        }
      };

      primary.forEach((item) => push(item, 'catalog'));
      extras.forEach((item) => push(item, 'local'));
      return Array.from(merged.values());
    }

    function loadLocalCatalogItems() {
      try {
        const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!stored) {
          return [];
        }
        const parsed = JSON.parse(stored);
        const items = Array.isArray(parsed?.items) ? parsed.items : [];
        return items
          .map((item, index) => normalizeCatalogItem(item, index + 1000))
          .filter(Boolean);
      } catch (error) {
        console.warn('Não foi possível carregar itens locais do catálogo.', error);
        return [];
      }
    }

    function escapeHtml(value) {
      return String(value ?? '').replace(/[&<>"']/g, (char) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
      })[char]);
    }

    const STATUS_CLASS_MAP = {
      essential: 'bg-indigo-100 text-indigo-800',
      available: 'bg-green-100 text-green-800',
      beta: 'bg-yellow-100 text-yellow-800',
      maintenance: 'bg-yellow-100 text-yellow-800',
      deprecated: 'bg-red-100 text-red-800',
    };

    const DEFAULT_STATUS_CLASS = 'bg-blue-100 text-blue-800';

    function getStatusClass(statusKey) {
      if (typeof statusKey !== 'string' || !statusKey.trim()) {
        return DEFAULT_STATUS_CLASS;
      }
      return STATUS_CLASS_MAP[statusKey.trim()] || DEFAULT_STATUS_CLASS;
    }

    function slugifyKey(value) {
      if (typeof value !== 'string') {
        return '';
      }
      return value
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/(^-|-$)/g, '')
        || '';
    }

    function normalizeTranslations(raw) {
      if (typeof raw !== 'object' || raw === null) {
        return {};
      }
      const sanitized = {};
      Object.entries(raw).forEach(([locale, fields]) => {
        if (typeof fields !== 'object' || fields === null) {
          return;
        }
        const normalizedFields = {};
        ['name', 'description', 'category', 'status'].forEach((field) => {
          if (typeof fields[field] === 'string' && fields[field].trim()) {
            normalizedFields[field] = fields[field].trim();
          }
        });
        if (Object.keys(normalizedFields).length > 0) {
          sanitized[locale] = normalizedFields;
        }
      });
      return sanitized;
    }

    function getLocalizedCatalogEntry(appItem, locale, messages = catalogMessages) {
      const base = {
        name: typeof appItem.name === 'string' ? appItem.name : '',
        description: typeof appItem.description === 'string' ? appItem.description : '',
        category: typeof appItem.category === 'string' ? appItem.category : '',
        status: typeof appItem.status === 'string' ? appItem.status : '',
      };

      if (typeof appItem.translations === 'object' && appItem.translations !== null) {
        const localized = appItem.translations[locale];
        if (typeof localized === 'object' && localized !== null) {
          ['name', 'description', 'category', 'status'].forEach((field) => {
            if (typeof localized[field] === 'string' && localized[field].trim()) {
              base[field] = localized[field].trim();
            }
          });
        }
      }

      if ((!base.status || !base.status.trim()) && appItem.statusKey && messages?.card?.statusByKey) {
        const fallbackStatus = messages.card.statusByKey[appItem.statusKey];
        if (typeof fallbackStatus === 'string' && fallbackStatus.trim()) {
          base.status = fallbackStatus.trim();
        }
      }

      return base;
    }

    function createCatalogCard(appItem) {
      const iconUrl = appItem.icon_url || 'https://placehold.co/48x48/cccccc/666666?text=APP';
      const localized = getLocalizedCatalogEntry(appItem, currentLocale);
      const statusClass = getStatusClass(appItem.statusKey);
      const requiredRoleAttr = appItem.requiredRole ? ` data-required-role="${escapeHtml(appItem.requiredRole)}"` : '';

      const safeName = escapeHtml(localized.name || 'MiniApp');
      const safeCategory = escapeHtml(localized.category || appItem.category || 'Geral');
      const safeDescription = escapeHtml(localized.description || appItem.description || '');
      const safeStatus = escapeHtml(localized.status || appItem.status || 'Desconhecido');
      const safeUrl = escapeHtml(appItem.url || '#');
      const openLabel = escapeHtml(catalogMessages.card.open);

      return `
        <div class="ma-card bg-white p-5 rounded-xl shadow border border-gray-100 flex flex-col justify-between hover:shadow-xl" data-catalog-card${requiredRoleAttr}>
          <div class="flex items-start space-x-4 mb-3">
            <img src="${iconUrl}" alt="${safeName} Ícone" class="w-10 h-10 rounded-lg object-cover border border-gray-200" onerror="this.onerror=null; this.src='https://placehold.co/48x48/cccccc/666666?text=APP';" />
            <div class="flex-1">
              <h4 class="text-lg font-semibold text-gray-900">${safeName}</h4>
              <p class="text-xs font-medium text-gray-500">${safeCategory}</p>
            </div>
          </div>
          <p class="text-sm text-gray-700 mb-4 h-12 overflow-hidden">${safeDescription}</p>
          <div class="flex items-center justify-between mt-auto pt-2 border-t border-gray-100">
            <span class="text-xs font-semibold px-2 py-0.5 rounded-full ${statusClass}">
              ${safeStatus}
            </span>
            <a
              href="#"
              class="text-sm font-medium text-indigo-600 hover:text-indigo-800 transition duration-150 ease-in-out"
              data-open-miniapp
              data-url="${safeUrl}"
              data-name="${safeName}"
              data-description="${safeDescription}"
              ${appItem.requiredRole ? `data-required-role="${escapeHtml(appItem.requiredRole)}"` : ''}
              data-open-label
            >
              <span data-open-label-text>${openLabel}</span> <i class="fas fa-external-link-alt ml-1 text-xs"></i>
            </a>
          </div>
        </div>
      `;
    }

    function refreshCatalogCardLabels() {
      if (!catalogList) return;
      const labelNodes = catalogList.querySelectorAll('[data-open-label-text]');
      labelNodes.forEach((node) => {
        node.textContent = catalogMessages.card.open;
      });
    }

    function applyRoleVisibility() {
      if (!catalogList) return;
      const cards = catalogList.querySelectorAll('[data-catalog-card]');
      cards.forEach((card) => {
        const requiredRole = card.getAttribute('data-required-role');
        const allowed = roleSatisfies(requiredRole, currentUserRole);
        card.hidden = !allowed;
        if (!allowed) {
          card.setAttribute('data-role-denied', 'true');
        } else {
          card.removeAttribute('data-role-denied');
        }
      });
    }

    function renderLoadingState(force = false) {
      if (!catalogList) return;
      if (!force && catalogList.dataset.renderState !== 'loading') {
        return;
      }
      catalogList.dataset.renderState = 'loading';
      const loadingMessage = escapeHtml(catalogMessages.status.loading);
      catalogList.innerHTML = `
        <div class="col-span-full flex flex-col justify-center items-center h-40 text-gray-500">
          <div class="loading-spinner w-8 h-8 border-4 border-gray-200 border-t-transparent border-t-indigo-500 rounded-full animate-spin mb-3"></div>
          ${loadingMessage}
        </div>`;
    }

    function populateFilters(data) {
      if (!categoryFilter) return;
      const categories = new Map();
      data.forEach((app) => {
        if (!app || !app.categoryKey) {
          return;
        }
        if (!categories.has(app.categoryKey)) {
          const localized = getLocalizedCatalogEntry(app, currentLocale);
          const label = localized.category || app.category || app.categoryKey;
          categories.set(app.categoryKey, label);
        }
      });
      const defaultOptionLabel = escapeHtml(catalogMessages.filterDefault);
      categoryFilter.innerHTML = `<option value="" data-default-option>${defaultOptionLabel}</option>`;
      const sortedCategories = [...categories.entries()].sort((a, b) => {
        const labelA = (a[1] || '').toString();
        const labelB = (b[1] || '').toString();
        return labelA.localeCompare(labelB, currentLocale);
      });
      sortedCategories.forEach(([key, label]) => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = label;
        categoryFilter.appendChild(option);
      });
      if (filterOptions.category && !categories.has(filterOptions.category)) {
        filterOptions.category = '';
      }
      categoryFilter.value = filterOptions.category;
    }

    function applyFiltersAndRender() {
      if (!catalogList) return;

      if (!Array.isArray(fullCatalogData) || fullCatalogData.length === 0) {
        catalogList.dataset.renderState = 'empty';
        catalogList.innerHTML = `<p class="text-gray-500 col-span-full p-4 text-center border border-dashed rounded-lg bg-gray-50">${escapeHtml(catalogMessages.status.empty)}</p>`;
        return;
      }

      const searchText = filterOptions.searchText.toLocaleLowerCase(currentLocale);
      const selectedCategory = filterOptions.category;

      const filteredData = fullCatalogData.filter((app, index) => {
        const matchesCategory = !selectedCategory || app.categoryKey === selectedCategory;
        if (!matchesCategory) {
          return false;
        }

        if (!searchText) {
          return true;
        }

        const localized = getLocalizedCatalogEntry(app, currentLocale);
        const fallbackName = typeof app.name === 'string' && app.name.trim()
          ? app.name
          : `MiniApp ${index + 1}`;
        const tokens = [
          localized.name,
          localized.description,
          localized.category,
          typeof app.name === 'string' ? app.name : '',
          typeof app.description === 'string' ? app.description : '',
          typeof app.category === 'string' ? app.category : '',
          fallbackName,
        ];

        return tokens.some((value) => typeof value === 'string'
          && value.toLocaleLowerCase(currentLocale).includes(searchText));
      });

      if (filteredData.length === 0) {
        catalogList.dataset.renderState = 'empty';
        catalogList.innerHTML = `<p class="text-gray-500 col-span-full p-4 text-center border border-dashed rounded-lg bg-gray-50">${escapeHtml(catalogMessages.status.noMatches)}</p>`;
        return;
      }

      catalogList.dataset.renderState = 'ready';
      catalogList.innerHTML = filteredData.map(createCatalogCard).join('');
      attachMiniAppOpenHandlers();
      refreshCatalogCardLabels();
      applyRoleVisibility();
    }

    function attachMiniAppOpenHandlers() {
      if (!catalogList) return;
      const triggers = catalogList.querySelectorAll('[data-open-miniapp]');
      triggers.forEach((trigger) => {
        trigger.addEventListener('click', (event) => {
          event.preventDefault();
          const { url, name, description } = trigger.dataset;
          const requiredRole = trigger.dataset.requiredRole || trigger.closest('[data-required-role]')?.dataset.requiredRole || '';
          if (!url) return;
          if (requiredRole && !roleSatisfies(requiredRole, currentUserRole)) {
            const roleLabel = formatRoleLabel(requiredRole);
            showStatus(null, `Acesso negado. Papel ${roleLabel} obrigatório.`, 'error');
            if (window.parent && typeof window.parent.postMessage === 'function') {
              window.parent.postMessage({ action: 'miniapp-access-denied', requiredRole }, '*');
            }
            return;
          }
          const metadata = {
            title: name || undefined,
            subtitle: description || undefined,
          };
          if (window.parent && typeof window.parent.postMessage === 'function') {
            window.parent.postMessage({ action: 'load-miniapp', url, metadata, requiredRole }, '*');
          } else if (window.parent && typeof window.parent.loadMiniApp === 'function') {
            window.parent.loadMiniApp(url, metadata, { requiredRole });
          } else {
            window.location.href = url;
          }
        });
      });
    }

    function normalizeCatalogItem(item, index = 0) {
      if (typeof item !== 'object' || item === null) {
        return null;
      }

      const fallbackId = `miniapp_${index + 1}`;
      const id = typeof item.id === 'string' && item.id.trim() ? item.id.trim() : fallbackId;
      const name = typeof item.name === 'string' && item.name.trim() ? item.name.trim() : `MiniApp ${index + 1}`;
      const description = typeof item.description === 'string' ? item.description : '';
      const category = typeof item.category === 'string' && item.category.trim() ? item.category.trim() : 'Geral';
      const status = typeof item.status === 'string' && item.status.trim() ? item.status.trim() : 'Disponível';
      const icon_url = typeof item.icon_url === 'string' && item.icon_url.trim() ? item.icon_url.trim() : null;
      const url = typeof item.url === 'string' && item.url.trim() ? item.url.trim() : null;
      const categoryKey = typeof item.category_key === 'string' && item.category_key.trim()
        ? item.category_key.trim()
        : slugifyKey(category);
      const statusKey = typeof item.status_key === 'string' && item.status_key.trim()
        ? item.status_key.trim()
        : slugifyKey(status);
      const requiredRole = typeof item.required_role === 'string' && item.required_role.trim()
        ? item.required_role.trim().toLowerCase()
        : '';
      const translations = normalizeTranslations(item.translations);

      if (!url) {
        return null;
      }

      return {
        id,
        name,
        description,
        category,
        status,
        icon_url,
        url,
        categoryKey,
        statusKey,
        requiredRole,
        translations,
      };
    }

    async function loadStaticCatalog() {
      showStatus('loading', catalogMessages.status.loading, 'info');
      renderLoadingState(true);

      let normalized = [];
      let loadError = null;

      try {
        const response = await fetch('../catalog.json', { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const json = await response.json();
        normalized = Array.isArray(json)
          ? json.map((item, index) => normalizeCatalogItem(item, index)).filter(Boolean)
          : [];
      } catch (error) {
        loadError = error;
        console.error('Erro ao carregar catalog.json:', error);
      }

      const localItems = loadLocalCatalogItems();
      fullCatalogData = mergeCatalogEntries(normalized, localItems);

      if (!fullCatalogData.length) {
        if (loadError) {
          catalogList.dataset.renderState = 'error';
          catalogList.innerHTML = `<p class="text-red-600 col-span-full p-4 text-center border border-dashed rounded-lg bg-red-50">${escapeHtml(catalogMessages.status.loadError)}</p>`;
          showStatus('loadError', catalogMessages.status.loadError, 'error', { message: loadError.message });
        } else {
          catalogList.dataset.renderState = 'empty';
          catalogList.innerHTML = `<p class="text-gray-500 col-span-full p-4 text-center border border-dashed rounded-lg bg-gray-50">${escapeHtml(catalogMessages.status.empty)}</p>`;
          showStatus('empty', catalogMessages.status.empty, 'info');
        }
        return;
      }

      populateFilters(fullCatalogData);
      applyFiltersAndRender();

      const statusContext = { count: fullCatalogData.length };
      if (localItems.length) {
        statusContext.localCount = localItems.length;
      }

      const tone = 'warning';
      const baseFallback = catalogMessages.status.firebaseMissing;
      const catalogLoadedText = formatTemplate(catalogMessages.status.catalogLoaded, statusContext).trim();

      showStatus('firebaseMissing', baseFallback, tone, statusContext);

      if (catalogLoadedText) {
        const combinedMessage = `${statusMessage.textContent} ${catalogLoadedText}`.trim();
        statusMessage.textContent = combinedMessage;
        currentStatusFallback = combinedMessage;
        currentStatusExtras = {
          key: 'catalogLoaded',
          fallback: catalogLoadedText,
          context: { ...statusContext },
        };
      }
    }

    if (searchBar) {
      searchBar.addEventListener('input', (event) => {
        filterOptions.searchText = event.target.value || '';
        applyFiltersAndRender();
      });
    }

    if (categoryFilter) {
      categoryFilter.addEventListener('change', (event) => {
        filterOptions.category = event.target.value || '';
        applyFiltersAndRender();
      });
    }

    function applyLanguage(locale, { notify = true } = {}) {
      currentLocale = typeof locale === 'string' ? locale : DEFAULT_LOCALE;
      catalogMessages = getCatalogMessages(currentLocale);
      document.documentElement.lang = currentLocale;
      document.documentElement.dir = getDirection(currentLocale);
      document.title = catalogMessages.documentTitle;

      if (catalogTitleEl) {
        catalogTitleEl.textContent = catalogMessages.headerTitle;
      }

      if (catalogSubtitleEl) {
        catalogSubtitleEl.textContent = catalogMessages.headerSubtitle;
      }

      if (searchBar) {
        searchBar.placeholder = catalogMessages.searchPlaceholder;
      }

      if (categoryFilter) {
        const defaultOption = categoryFilter.querySelector('[data-default-option]');
        if (defaultOption) {
          defaultOption.textContent = catalogMessages.filterDefault;
        }
      }

      if (currentStatusKey) {
        const baseMessage = translateStatus(currentStatusKey, currentStatusFallback, currentStatusContext);
        let combinedMessage = baseMessage;
        if (currentStatusExtras?.key) {
          const extraMessage = translateStatus(
            currentStatusExtras.key,
            currentStatusExtras.fallback,
            currentStatusExtras.context || {}
          );
          combinedMessage = `${baseMessage} ${extraMessage}`.trim();
        }
        statusMessage.textContent = combinedMessage;
        currentStatusFallback = combinedMessage;
      } else {
        statusMessage.textContent = currentStatusFallback || '';
      }

      populateFilters(fullCatalogData);
      applyFiltersAndRender();
      refreshCatalogCardLabels();

      if (notify && window.parent && typeof window.parent.postMessage === 'function') {
        window.parent.postMessage({ action: 'miniapp-language-applied', locale: currentLocale }, '*');
      }
    }

    window.addEventListener('message', (event) => {
      const { data } = event;
      if (!data || typeof data !== 'object') {
        return;
      }
      if (data.action === 'shell-language') {
        applyLanguage(data.locale);
      } else if (data.action === 'shell-session') {
        authGuardsDisabled = Boolean(data.guardsDisabled);
        currentUserRole = data.session?.role || null;
        applyRoleVisibility();
      } else if (data.action === 'shell-access-denied') {
        const label = formatRoleLabel(data.requiredRole);
        showStatus(null, `Acesso negado. Papel ${label} obrigatório.`, 'error');
      }
    });

    applyLanguage(currentLocale, { notify: false });
    showStatus('initializing', catalogMessages.status.initializing, 'info');
    renderLoadingState(true);
    loadStaticCatalog();

    if (window.parent && typeof window.parent.postMessage === 'function') {
      window.parent.postMessage({ action: 'miniapp-language-ready' }, '*');
      window.parent.postMessage({ action: 'miniapp-session-ready' }, '*');
    }
  </script>

  <script>
    (function () {
      const themeHost = document.body;

      const applyTheme = (theme) => {
        if (!themeHost) return;
        const normalizedTheme = theme === 'dark' ? 'dark' : 'light';
        themeHost.setAttribute('data-theme', normalizedTheme);

        if (window.parent && typeof window.parent.postMessage === 'function') {
          window.parent.postMessage({ action: 'miniapp-theme-applied', theme: normalizedTheme }, '*');
        }
      };

      window.addEventListener('message', (event) => {
        const { data } = event;
        if (!data || data.action !== 'shell-theme') {
          return;
        }
        applyTheme(data.theme);
      });

      if (window.parent && typeof window.parent.postMessage === 'function') {
        window.parent.postMessage({ action: 'miniapp-theme-ready' }, '*');
      }
    }());
  </script>
</body>
</html>
