<!DOCTYPE html>
<html lang="pt-BR" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gerador de Roteiros para TTS</title>
  <link rel="stylesheet" href="../miniapp-base/style/styles.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      min-height: 100vh;
    }

    .tts-shell {
      padding: clamp(24px, 5vw, 64px);
      background: var(--background-page);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .tts-container {
      max-width: 960px;
      margin: 0 auto;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: clamp(24px, 4vw, 40px);
    }

    .tts-header {
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 3vw, 24px);
    }

    .tts-header__title h1 {
      font-size: clamp(1.5rem, 4vw, 2.25rem);
      margin: 0;
    }

    .tts-header__title p {
      margin: 0;
      color: var(--text-color-muted);
      font-size: var(--font-size-l);
    }

    .tts-language-picker {
      display: grid;
      gap: var(--space-2);
      align-self: flex-start;
    }

    .tts-language-picker label {
      font-size: var(--font-size-m);
      font-weight: 600;
      color: var(--text-color-muted);
    }

    .tts-language-picker select {
      min-width: 200px;
      padding: var(--space-3);
      border-radius: var(--radius-m);
      border: var(--border-default);
      background: var(--background-surface);
      color: var(--text-color-primary);
      font-size: var(--font-size-l);
    }

    .tts-card {
      background: var(--background-surface);
      border: var(--border-default);
      border-radius: var(--radius-xl);
      padding: clamp(24px, 4vw, 40px);
      box-shadow: var(--box-shadow-default);
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 3vw, 24px);
    }

    .tts-form fieldset {
      border: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: clamp(16px, 3vw, 24px);
    }

    .tts-form legend {
      font-size: clamp(1.125rem, 3vw, 1.5rem);
      font-weight: 700;
      margin-bottom: var(--space-2);
    }

    .tts-form__description {
      margin: 0;
      color: var(--text-color-muted);
      font-size: var(--font-size-l);
    }

    .tts-form__grid {
      display: grid;
      gap: clamp(16px, 3vw, 24px);
    }

    .tts-field {
      display: grid;
      gap: var(--space-2);
    }

    .tts-field label {
      font-weight: 600;
      font-size: var(--font-size-l);
    }

    .tts-input,
    .tts-textarea,
    #scriptOutput {
      width: 100%;
      border-radius: var(--radius-m);
      border: var(--border-default);
      background: var(--background-surface-alternate);
      color: var(--text-color-primary);
      font-size: var(--font-size-l);
      padding: var(--space-3);
      resize: vertical;
      min-height: 48px;
    }

    .tts-textarea {
      min-height: 96px;
    }

    #scriptOutput {
      min-height: clamp(200px, 40vh, 360px);
      resize: vertical;
    }

    .tts-actions {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-3);
    }

    .tts-actions .btn {
      min-width: clamp(160px, 30vw, 220px);
    }

    .tts-output-status {
      margin: 0;
      color: var(--text-color-muted);
      font-size: var(--font-size-m);
    }

    .tts-card .controls {
      display: grid;
      gap: clamp(12px, 3vw, 20px);
    }

    .tts-control {
      display: grid;
      gap: var(--space-2);
    }

    .tts-control__header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: var(--space-2);
    }

    .tts-control__value {
      font-weight: 600;
      color: var(--text-color-muted);
      font-size: var(--font-size-m);
    }

    .tts-control__helper {
      margin: 0;
      color: var(--text-color-muted);
      font-size: var(--font-size-m);
    }

    .tts-slider {
      width: 100%;
      accent-color: var(--color-primary, #0053ff);
    }

    .tts-audio-header {
      display: grid;
      gap: var(--space-2);
    }

    .tts-audio-footer {
      display: grid;
      gap: var(--space-2);
    }

    .tts-history-header {
      display: grid;
      gap: var(--space-2);
    }

    .tts-history-actions {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }

    .tts-history-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: clamp(12px, 3vw, 20px);
    }

    .tts-history-item {
      border: var(--border-default);
      border-radius: var(--radius-l);
      padding: clamp(12px, 2vw, 20px);
      background: var(--background-surface-alternate);
      display: grid;
      gap: var(--space-3);
    }

    .tts-history-item__meta {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-3);
      color: var(--text-color-muted);
      font-size: var(--font-size-m);
    }

    .tts-history-item__meta span {
      display: inline-flex;
      gap: var(--space-1);
      align-items: baseline;
    }

    .tts-history-item__meta span strong {
      font-weight: 600;
      color: var(--text-color-primary);
    }

    .tts-history-item__actions {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }

    .tts-history-item__actions .btn {
      min-width: auto;
    }

    .tts-history-item__audio {
      width: 100%;
    }

    .tts-history-empty {
      margin: 0;
      color: var(--text-color-muted);
      font-size: var(--font-size-m);
    }

    .tts-audio-player {
      width: 100%;
      border-radius: var(--radius-m);
      background: var(--background-surface-alternate);
    }

    @media (min-width: 720px) {
      .tts-header {
        flex-direction: row;
        align-items: flex-start;
        justify-content: space-between;
      }

      .tts-form__grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .tts-field--full {
        grid-column: 1 / -1;
      }
    }
  </style>
</head>
<body>
  <div class="tts-shell">
    <div class="tts-container">
      <header class="tts-header">
        <div class="tts-header__title">
          <h1 data-i18n="app.title">Gerador de Roteiros para TTS</h1>
          <p data-i18n="app.subtitle">Combine dados essenciais para gerar um roteiro consistente de locução.</p>
        </div>
        <div class="tts-language-picker">
          <label for="languageSelect" data-i18n="language.label">Idioma</label>
          <select id="languageSelect" aria-describedby="languageHelper">
            <option value="pt-BR" data-i18n-option="language.pt-BR">Português (Brasil)</option>
            <option value="en-US" data-i18n-option="language.en-US">English (US)</option>
            <option value="es-ES" data-i18n-option="language.es-ES">Español (ES)</option>
          </select>
          <span id="languageHelper" class="tts-output-status" data-i18n="language.helper">Escolha o idioma da interface.</span>
        </div>
      </header>

      <main class="tts-main">
        <section class="tts-card">
          <form id="scriptForm" class="tts-form">
            <fieldset>
              <legend data-i18n="form.legend">Informações essenciais</legend>
              <p class="tts-form__description" data-i18n="form.description">Preencha os campos abaixo para montar um roteiro automaticamente.</p>
              <div class="tts-form__grid">
                <div class="tts-field">
                  <label for="cityInput" data-i18n="form.city.label">Cidade</label>
                  <input type="text" id="cityInput" class="tts-input" name="city" required data-i18n-placeholder="form.city.placeholder" placeholder="Ex.: Recife">
                </div>
                <div class="tts-field">
                  <label for="audienceInput" data-i18n="form.audience.label">Público</label>
                  <input type="text" id="audienceInput" class="tts-input" name="audience" required data-i18n-placeholder="form.audience.placeholder" placeholder="Ex.: moradores, empreendedores locais">
                </div>
                <div class="tts-field tts-field--full">
                  <label for="highlightInput" data-i18n="form.highlight.label">Destaque</label>
                  <textarea id="highlightInput" class="tts-textarea" name="highlight" rows="3" required data-i18n-placeholder="form.highlight.placeholder" placeholder="Ex.: novo centro de apoio ao empreendedor"></textarea>
                </div>
                <div class="tts-field tts-field--full">
                  <label for="ctaInput" data-i18n="form.cta.label">Chamada à ação</label>
                  <textarea id="ctaInput" class="tts-textarea" name="cta" rows="3" required data-i18n-placeholder="form.cta.placeholder" placeholder="Ex.: inscreva-se no site da prefeitura"></textarea>
                </div>
              </div>
              <div class="tts-actions">
                <button type="submit" id="generateButton" class="btn primary" data-i18n="actions.generate">Gerar roteiro</button>
              </div>
            </fieldset>
          </form>
        </section>

        <section class="tts-card">
          <div class="tts-output-header">
            <h2 data-i18n="output.label">Roteiro gerado</h2>
            <p id="outputStatus" class="tts-output-status" aria-live="polite" data-i18n="output.helper">Preencha o formulário para gerar um roteiro automático.</p>
          </div>
          <textarea id="scriptOutput" name="script" rows="10" readonly data-i18n-placeholder="output.placeholder" placeholder="O roteiro aparecerá aqui após a geração."></textarea>
          <div class="tts-actions">
            <button type="button" id="editButton" class="btn ghost" data-i18n="actions.edit" disabled>Editar manualmente</button>
          </div>
        </section>

        <section class="tts-card">
          <div class="tts-audio-header">
            <h2 id="audioTitle" data-i18n="audio.title">Prévia de áudio</h2>
            <p id="audioDescription" class="tts-output-status" data-i18n="audio.description">Ajuste as opções e gere um arquivo de áudio simplificado para revisão.</p>
          </div>
          <div class="controls">
            <div class="tts-control">
              <div class="tts-control__header">
                <label for="audioSpeed" data-audio-label="speed" data-i18n="audio.controls.speed.label">Velocidade</label>
                <span class="tts-control__value" data-audio-value="speed">1,00×</span>
              </div>
              <input type="range" id="audioSpeed" class="tts-slider" min="0.5" max="1.5" step="0.05" value="1" aria-describedby="audioSpeedHelper" data-audio-input="speed" data-i18n-title="audio.controls.speed.tooltip" title="Defina a rapidez da narração.">
              <p id="audioSpeedHelper" class="tts-control__helper" data-audio-helper="speed" data-i18n="audio.controls.speed.helper">Controla a rapidez da locução na prévia.</p>
            </div>
            <div class="tts-control">
              <div class="tts-control__header">
                <label for="audioVolume" data-audio-label="volume" data-i18n="audio.controls.volume.label">Volume</label>
                <span class="tts-control__value" data-audio-value="volume">100%</span>
              </div>
              <input type="range" id="audioVolume" class="tts-slider" min="0" max="1" step="0.05" value="1" aria-describedby="audioVolumeHelper" data-audio-input="volume" data-i18n-title="audio.controls.volume.tooltip" title="Ajuste o volume da narração.">
              <p id="audioVolumeHelper" class="tts-control__helper" data-audio-helper="volume" data-i18n="audio.controls.volume.helper">Equilibra o volume aplicado à prévia e ao download.</p>
            </div>
            <div class="tts-control">
              <div class="tts-control__header">
                <label for="audioPause" data-audio-label="pause" data-i18n="audio.controls.pause.label">Pausa entre trechos</label>
                <span class="tts-control__value" data-audio-value="pause">0,6 s</span>
              </div>
              <input type="range" id="audioPause" class="tts-slider" min="0" max="3" step="0.1" value="0.6" aria-describedby="audioPauseHelper" data-audio-input="pause" data-i18n-title="audio.controls.pause.tooltip" title="Defina a pausa entre cada bloco do texto.">
              <p id="audioPauseHelper" class="tts-control__helper" data-audio-helper="pause" data-i18n="audio.controls.pause.helper">Controla o silêncio entre os blocos do roteiro.</p>
            </div>
          </div>
          <div class="tts-actions">
            <button type="button" id="audioGenerateButton" class="btn primary" data-i18n="audio.actions.preview" disabled>Gerar prévia de áudio</button>
            <button type="button" id="audioDownloadButton" class="btn ghost" data-i18n="audio.actions.download" disabled>Baixar áudio (WAV)</button>
          </div>
          <div class="tts-audio-footer">
            <p id="audioStatus" class="tts-output-status">Gere um roteiro para habilitar a prévia de áudio.</p>
            <audio id="audioPlayer" class="tts-audio-player" controls preload="none"></audio>
          </div>
        </section>

        <section class="tts-card">
          <div class="tts-history-header">
            <h2 id="historyTitle" data-i18n="history.title">Histórico</h2>
            <p id="historyDescription" class="tts-output-status" data-i18n="history.description">Consulte os áudios já gerados para ouvir novamente ou baixar.</p>
          </div>
          <div class="tts-history-actions">
            <button type="button" id="historyClearButton" class="btn ghost" data-i18n="history.actions.clear" disabled>Limpar histórico</button>
          </div>
          <ul id="historyList" class="tts-history-list" aria-live="polite"></ul>
          <p id="historyEmptyState" class="tts-history-empty" data-i18n="history.empty">Nenhum áudio gerado ainda.</p>
        </section>
      </main>
    </div>
  </div>

  <script>
    const translations = {
      'pt-BR': {
        pageTitle: 'Gerador de Roteiros para TTS',
        appTitle: 'Gerador de Roteiros para TTS',
        appSubtitle: 'Combine dados essenciais para gerar um roteiro consistente de locução.',
        languageLabel: 'Idioma',
        languageHelper: 'Escolha o idioma da interface.',
        languageNames: {
          'language.pt-BR': 'Português (Brasil)',
          'language.en-US': 'English (US)',
          'language.es-ES': 'Español (ES)'
        },
        formLegend: 'Informações essenciais',
        formDescription: 'Preencha os campos abaixo para montar um roteiro automaticamente.',
        fields: {
          city: { label: 'Cidade', placeholder: 'Ex.: Recife' },
          audience: { label: 'Público', placeholder: 'Ex.: moradores, empreendedores locais' },
          highlight: { label: 'Destaque', placeholder: 'Ex.: novo centro de apoio ao empreendedor' },
          cta: { label: 'Chamada à ação', placeholder: 'Ex.: inscreva-se no site da prefeitura' }
        },
        actions: {
          generate: 'Gerar roteiro',
          edit: 'Editar manualmente'
        },
        outputLabel: 'Roteiro gerado',
        outputPlaceholder: 'O roteiro aparecerá aqui após a geração.',
        outputHelper: 'Preencha o formulário para gerar um roteiro automático.',
        outputGenerated: 'Roteiro gerado automaticamente com base nas informações fornecidas.',
        outputManual: 'Edição manual ativada. Revise o texto antes de publicar.',
        basePhrases: {
          greeting: 'Olá, {audience} de {city}!',
          highlight: 'Hoje queremos destacar {highlight}.',
          cta: 'Para finalizar, {cta}.'
        },
        audio: {
          title: 'Prévia de áudio',
          description: 'Personalize os ajustes antes de gerar a prévia simplificada e o download.',
          controls: {
            speed: {
              label: 'Velocidade',
              helper: 'Controla a rapidez da locução gerada.',
              tooltip: 'Defina a velocidade da prévia e do download.',
              unit: '×'
            },
            volume: {
              label: 'Volume',
              helper: 'Equilibra o volume aplicado à prévia e ao arquivo baixado.',
              tooltip: 'Ajuste o volume da locução final.',
              unit: '%'
            },
            pause: {
              label: 'Pausa entre blocos',
              helper: 'Controla o silêncio entre os parágrafos do roteiro.',
              tooltip: 'Defina o tempo de silêncio entre cada parte do texto.',
              unit: 's'
            }
          },
          actions: {
            preview: 'Gerar prévia de áudio',
            previewTooltip: 'Reprocessa o áudio com as configurações atuais.',
            download: 'Baixar áudio (WAV)',
            downloadTooltip: 'Baixe o arquivo de áudio com as configurações aplicadas.'
          },
          status: {
            empty: 'Gere um roteiro para habilitar a prévia de áudio.',
            idle: 'Ajuste as opções e gere o áudio para ouvir a prévia.',
            generating: 'Gerando áudio com as configurações selecionadas…',
            ready: 'Áudio gerado. Prévia e download usam as configurações atuais.',
            needsRegeneration: 'As configurações mudaram. Gere novamente para atualizar o áudio.',
            error: 'Não foi possível gerar o áudio. Tente novamente.'
          }
        },
        history: {
          title: 'Histórico',
          description: 'Consulte os áudios já gerados para ouvir novamente ou baixar.',
          empty: 'Nenhum áudio gerado ainda.',
          labels: {
            createdAt: 'Gerado em',
            language: 'Idioma',
            duration: 'Duração'
          },
          actions: {
            play: 'Ouvir',
            download: 'Baixar (WAV)',
            remove: 'Remover',
            clear: 'Limpar histórico'
          }
        }
      },
      'en-US': {
        pageTitle: 'TTS Script Generator',
        appTitle: 'TTS Script Generator',
        appSubtitle: 'Combine key inputs to craft a consistent narration draft.',
        languageLabel: 'Language',
        languageHelper: 'Choose the interface language.',
        languageNames: {
          'language.pt-BR': 'Portuguese (Brazil)',
          'language.en-US': 'English (US)',
          'language.es-ES': 'Spanish (ES)'
        },
        formLegend: 'Key information',
        formDescription: 'Fill in the fields below to automatically compose a narration script.',
        fields: {
          city: { label: 'City', placeholder: 'e.g., Recife' },
          audience: { label: 'Audience', placeholder: 'e.g., residents, local entrepreneurs' },
          highlight: { label: 'Highlight', placeholder: 'e.g., new entrepreneurship support center' },
          cta: { label: 'Call to action', placeholder: 'e.g., register on the city hall website' }
        },
        actions: {
          generate: 'Generate script',
          edit: 'Edit manually'
        },
        outputLabel: 'Generated script',
        outputPlaceholder: 'The narration script will appear here after generation.',
        outputHelper: 'Fill in the form to generate a narration script automatically.',
        outputGenerated: 'Script generated automatically from the provided information.',
        outputManual: 'Manual editing enabled. Review the final copy before sharing.',
        basePhrases: {
          greeting: 'Hello, {audience} from {city}!',
          highlight: 'Today we want to highlight {highlight}.',
          cta: 'To wrap up, {cta}.'
        },
        audio: {
          title: 'Audio preview',
          description: 'Fine-tune the options before generating the simplified preview and download.',
          controls: {
            speed: {
              label: 'Speed',
              helper: 'Controls how fast the narration will sound.',
              tooltip: 'Set the playback speed for preview and download.',
              unit: '×'
            },
            volume: {
              label: 'Volume',
              helper: 'Balances the loudness applied to the preview and exported file.',
              tooltip: 'Adjust the narration volume for the final audio.',
              unit: '%'
            },
            pause: {
              label: 'Pause between blocks',
              helper: 'Controls the silence inserted between each paragraph.',
              tooltip: 'Set the amount of silence between sections of the script.',
              unit: 's'
            }
          },
          actions: {
            preview: 'Generate audio preview',
            previewTooltip: 'Reprocess the audio with the current settings.',
            download: 'Download audio (WAV)',
            downloadTooltip: 'Download the audio file with the selected settings.'
          },
          status: {
            empty: 'Generate a script to enable the audio preview.',
            idle: 'Adjust the options and generate the audio to listen to the preview.',
            generating: 'Generating audio with the selected settings…',
            ready: 'Audio generated. Preview and download use the current settings.',
            needsRegeneration: 'Settings have changed. Generate again to refresh the audio.',
            error: 'Unable to generate audio. Please try again.'
          }
        },
        history: {
          title: 'History',
          description: 'Review previously generated audio files to listen again or download.',
          empty: 'No audio has been generated yet.',
          labels: {
            createdAt: 'Created on',
            language: 'Language',
            duration: 'Duration'
          },
          actions: {
            play: 'Listen',
            download: 'Download (WAV)',
            remove: 'Remove',
            clear: 'Clear history'
          }
        }
      },
      'es-ES': {
        pageTitle: 'Generador de guiones para TTS',
        appTitle: 'Generador de guiones para TTS',
        appSubtitle: 'Combina datos clave para crear un guion de locución coherente.',
        languageLabel: 'Idioma',
        languageHelper: 'Elige el idioma de la interfaz.',
        languageNames: {
          'language.pt-BR': 'Portugués (Brasil)',
          'language.en-US': 'Inglés (EE. UU.)',
          'language.es-ES': 'Español (ES)'
        },
        formLegend: 'Información esencial',
        formDescription: 'Completa los campos para generar automáticamente el guion de la locución.',
        fields: {
          city: { label: 'Ciudad', placeholder: 'Ej.: Recife' },
          audience: { label: 'Público', placeholder: 'Ej.: residentes, emprendedores locales' },
          highlight: { label: 'Destacado', placeholder: 'Ej.: nuevo centro de apoyo al emprendedor' },
          cta: { label: 'Llamado a la acción', placeholder: 'Ej.: inscríbete en el sitio del ayuntamiento' }
        },
        actions: {
          generate: 'Generar guion',
          edit: 'Editar manualmente'
        },
        outputLabel: 'Guion generado',
        outputPlaceholder: 'El guion aparecerá aquí después de generarse.',
        outputHelper: 'Completa el formulario para generar un guion automático.',
        outputGenerated: 'Guion generado automáticamente con la información proporcionada.',
        outputManual: 'Edición manual activada. Revisa el texto antes de publicar.',
        basePhrases: {
          greeting: '¡Hola, {audience} de {city}!',
          highlight: 'Hoy queremos destacar {highlight}.',
          cta: 'Para finalizar, {cta}.'
        },
        audio: {
          title: 'Previsualización de audio',
          description: 'Ajusta las opciones antes de generar la previsualización simplificada y la descarga.',
          controls: {
            speed: {
              label: 'Velocidad',
              helper: 'Controla qué tan rápido sonará la locución.',
              tooltip: 'Define la velocidad de reproducción para la previsualización y la descarga.',
              unit: '×'
            },
            volume: {
              label: 'Volumen',
              helper: 'Equilibra el volumen aplicado a la previsualización y al archivo exportado.',
              tooltip: 'Ajusta el volumen final de la locución.',
              unit: '%'
            },
            pause: {
              label: 'Pausa entre bloques',
              helper: 'Controla el silencio insertado entre cada párrafo.',
              tooltip: 'Define el tiempo de silencio entre las secciones del guion.',
              unit: 's'
            }
          },
          actions: {
            preview: 'Generar previsualización de audio',
            previewTooltip: 'Reprocesa el audio con la configuración actual.',
            download: 'Descargar audio (WAV)',
            downloadTooltip: 'Descarga el archivo de audio con los ajustes seleccionados.'
          },
          status: {
            empty: 'Genera un guion para habilitar la previsualización de audio.',
            idle: 'Ajusta las opciones y genera el audio para escuchar la previsualización.',
            generating: 'Generando audio con la configuración seleccionada…',
            ready: 'Audio generado. La previsualización y la descarga usan la configuración actual.',
            needsRegeneration: 'La configuración cambió. Genera nuevamente para actualizar el audio.',
            error: 'No fue posible generar el audio. Inténtalo otra vez.'
          }
        },
        history: {
          title: 'Historial',
          description: 'Consulta los audios generados para escucharlos nuevamente o descargarlos.',
          empty: 'Todavía no se ha generado ningún audio.',
          labels: {
            createdAt: 'Generado el',
            language: 'Idioma',
            duration: 'Duración'
          },
          actions: {
            play: 'Escuchar',
            download: 'Descargar (WAV)',
            remove: 'Eliminar',
            clear: 'Limpiar historial'
          }
        }
      }
    };

    const state = {
      currentLanguage: 'pt-BR',
      lastGeneratedValues: null,
      manualOverride: false,
      audio: {
        settings: {
          speed: 1,
          volume: 1,
          pause: 0.6
        },
        status: 'empty',
        blob: null,
        objectUrl: null,
        isProcessing: false,
        needsRegeneration: false,
        hasScript: false
      },
      history: {
        entries: []
      }
    };

    const languageSelect = document.getElementById('languageSelect');
    const form = document.getElementById('scriptForm');
    const cityInput = document.getElementById('cityInput');
    const audienceInput = document.getElementById('audienceInput');
    const highlightInput = document.getElementById('highlightInput');
    const ctaInput = document.getElementById('ctaInput');
    const generateButton = document.getElementById('generateButton');
    const editButton = document.getElementById('editButton');
    const scriptOutput = document.getElementById('scriptOutput');
    const outputStatus = document.getElementById('outputStatus');
    const titleElement = document.querySelector('[data-i18n="app.title"]');
    const subtitleElement = document.querySelector('[data-i18n="app.subtitle"]');
    const languageLabel = document.querySelector('[data-i18n="language.label"]');
    const languageHelper = document.querySelector('[data-i18n="language.helper"]');
    const formLegend = document.querySelector('[data-i18n="form.legend"]');
    const formDescription = document.querySelector('[data-i18n="form.description"]');
    const outputLabel = document.querySelector('[data-i18n="output.label"]');
    const audioTitle = document.getElementById('audioTitle');
    const audioDescription = document.getElementById('audioDescription');
    const audioPlayer = document.getElementById('audioPlayer');
    const audioStatus = document.getElementById('audioStatus');
    const audioGenerateButton = document.getElementById('audioGenerateButton');
    const audioDownloadButton = document.getElementById('audioDownloadButton');
    const audioValueElements = {
      speed: document.querySelector('[data-audio-value="speed"]'),
      volume: document.querySelector('[data-audio-value="volume"]'),
      pause: document.querySelector('[data-audio-value="pause"]')
    };
    const audioInputs = {
      speed: document.getElementById('audioSpeed'),
      volume: document.getElementById('audioVolume'),
      pause: document.getElementById('audioPause')
    };
    const audioLabels = {
      speed: document.querySelector('[data-audio-label="speed"]'),
      volume: document.querySelector('[data-audio-label="volume"]'),
      pause: document.querySelector('[data-audio-label="pause"]')
    };
    const audioHelpers = {
      speed: document.querySelector('[data-audio-helper="speed"]'),
      volume: document.querySelector('[data-audio-helper="volume"]'),
      pause: document.querySelector('[data-audio-helper="pause"]')
    };
    const historyTitle = document.getElementById('historyTitle');
    const historyDescription = document.getElementById('historyDescription');
    const historyList = document.getElementById('historyList');
    const historyEmptyState = document.getElementById('historyEmptyState');
    const historyClearButton = document.getElementById('historyClearButton');
    const HISTORY_STORAGE_KEY = 'ttsAudioHistory';

    function replacePlaceholders(template, values) {
      return template
        .replace('{city}', values.city)
        .replace('{audience}', values.audience)
        .replace('{highlight}', values.highlight)
        .replace('{cta}', values.cta);
    }

    function composeScript(values, language) {
      const phrases = translations[language].basePhrases;
      return [
        replacePlaceholders(phrases.greeting, values),
        replacePlaceholders(phrases.highlight, values),
        replacePlaceholders(phrases.cta, values)
      ].join('\n\n');
    }

    function getFieldTranslations(language) {
      return translations[language].fields;
    }

    function buildAudioFileName(settings) {
      const speedValue = Math.round((settings?.speed ?? 1) * 100);
      const volumeValue = Math.round((settings?.volume ?? 1) * 100);
      const pauseValue = Math.round((settings?.pause ?? 0) * 1000);
      return `roteiro-tts-spd${speedValue}-vol${volumeValue}-pause${pauseValue}.wav`;
    }

    function formatDuration(seconds, language) {
      if (!Number.isFinite(seconds) || seconds <= 0) {
        return new Intl.NumberFormat(language).format(0) + ':00';
      }
      const totalSeconds = Math.max(0, Math.round(seconds));
      const minutes = Math.floor(totalSeconds / 60);
      const remainingSeconds = totalSeconds % 60;
      const formattedSeconds = remainingSeconds.toString().padStart(2, '0');
      return `${minutes}:${formattedSeconds}`;
    }

    function formatDate(isoString, language) {
      try {
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          throw new Error('Invalid date value');
        }
        return new Intl.DateTimeFormat(language, {
          dateStyle: 'short',
          timeStyle: 'short'
        }).format(date);
      } catch (error) {
        console.error('Falha ao formatar data do histórico:', error);
        return isoString;
      }
    }

    function blobToDataUrl(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          if (typeof reader.result === 'string') {
            resolve(reader.result);
          } else {
            reject(new Error('Invalid data URL result.'));
          }
        };
        reader.onerror = () => {
          reject(reader.error || new Error('Failed to convert blob to data URL.'));
        };
        reader.readAsDataURL(blob);
      });
    }

    function loadHistoryFromStorage() {
      if (typeof localStorage === 'undefined') {
        return [];
      }

      try {
        const storedValue = localStorage.getItem(HISTORY_STORAGE_KEY);
        if (!storedValue) {
          return [];
        }
        const parsed = JSON.parse(storedValue);
        if (!Array.isArray(parsed)) {
          return [];
        }

        return parsed
          .filter((entry) => entry && typeof entry === 'object' && typeof entry.audioUrl === 'string')
          .map((entry) => ({
            id: String(entry.id || Date.now()),
            createdAt: entry.createdAt || new Date().toISOString(),
            language: entry.language || 'pt-BR',
            duration: typeof entry.duration === 'number' ? entry.duration : 0,
            settings: {
              speed: typeof entry?.settings?.speed === 'number' ? entry.settings.speed : 1,
              volume: typeof entry?.settings?.volume === 'number' ? entry.settings.volume : 1,
              pause: typeof entry?.settings?.pause === 'number' ? entry.settings.pause : 0.6
            },
            audioUrl: entry.audioUrl,
            fileName: entry.fileName || buildAudioFileName(entry.settings || {}),
            script: typeof entry.script === 'string' ? entry.script : ''
          }));
      } catch (error) {
        console.error('Falha ao carregar histórico de áudio:', error);
        return [];
      }
    }

    function saveHistoryToStorage(entries) {
      if (typeof localStorage === 'undefined') {
        return;
      }

      try {
        localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(entries));
      } catch (error) {
        console.error('Falha ao salvar histórico de áudio:', error);
      }
    }

    function getHistoryLanguageLabel(language) {
      const localeTexts = translations[state.currentLanguage];
      const key = `language.${language}`;
      return localeTexts.languageNames[key] || language;
    }

    function renderHistory() {
      const localeTexts = translations[state.currentLanguage];
      const historyTexts = localeTexts.history;
      const entries = state.history.entries;

      if (historyEmptyState) {
        historyEmptyState.textContent = historyTexts.empty;
        historyEmptyState.hidden = entries.length > 0;
      }

      if (!historyList) {
        return;
      }

      historyList.querySelectorAll('audio[data-history-audio]').forEach((audioElement) => {
        audioElement.pause();
      });

      historyList.innerHTML = '';
      historyList.hidden = entries.length === 0;

      if (entries.length === 0) {
        if (historyClearButton) {
          historyClearButton.disabled = true;
        }
        return;
      }

      entries.forEach((entry) => {
        const item = document.createElement('li');
        item.className = 'tts-history-item';
        item.setAttribute('data-history-id', entry.id);

        const meta = document.createElement('div');
        meta.className = 'tts-history-item__meta';

        const dateSpan = document.createElement('span');
        const dateLabel = document.createElement('strong');
        dateLabel.textContent = `${historyTexts.labels.createdAt}:`;
        dateSpan.append(dateLabel, document.createTextNode(` ${formatDate(entry.createdAt, state.currentLanguage)}`));

        const languageSpan = document.createElement('span');
        const languageLabel = document.createElement('strong');
        languageLabel.textContent = `${historyTexts.labels.language}:`;
        languageSpan.append(languageLabel, document.createTextNode(` ${getHistoryLanguageLabel(entry.language)}`));

        const durationSpan = document.createElement('span');
        const durationLabel = document.createElement('strong');
        durationLabel.textContent = `${historyTexts.labels.duration}:`;
        durationSpan.append(durationLabel, document.createTextNode(` ${formatDuration(entry.duration, state.currentLanguage)}`));

        meta.append(dateSpan, languageSpan, durationSpan);
        item.append(meta);

        const actions = document.createElement('div');
        actions.className = 'tts-history-item__actions';

        const playButton = document.createElement('button');
        playButton.type = 'button';
        playButton.className = 'btn primary';
        playButton.textContent = historyTexts.actions.play;
        playButton.setAttribute('data-history-action', 'play');
        playButton.setAttribute('data-history-id', entry.id);

        const downloadButton = document.createElement('button');
        downloadButton.type = 'button';
        downloadButton.className = 'btn ghost';
        downloadButton.textContent = historyTexts.actions.download;
        downloadButton.setAttribute('data-history-action', 'download');
        downloadButton.setAttribute('data-history-id', entry.id);

        const removeButton = document.createElement('button');
        removeButton.type = 'button';
        removeButton.className = 'btn ghost';
        removeButton.textContent = historyTexts.actions.remove;
        removeButton.setAttribute('data-history-action', 'remove');
        removeButton.setAttribute('data-history-id', entry.id);

        actions.append(playButton, downloadButton, removeButton);
        item.append(actions);

        const audioElement = document.createElement('audio');
        audioElement.className = 'tts-history-item__audio';
        audioElement.setAttribute('data-history-audio', entry.id);
        audioElement.preload = 'none';
        audioElement.controls = true;
        audioElement.hidden = true;
        item.append(audioElement);

        historyList.append(item);
      });

      if (historyClearButton) {
        historyClearButton.disabled = entries.length === 0;
      }
    }

    function setHistoryEntries(entries) {
      state.history.entries = entries;
      saveHistoryToStorage(entries);
    }

    function addHistoryEntry(entry) {
      const updatedEntries = [entry, ...state.history.entries];
      setHistoryEntries(updatedEntries);
      renderHistory();
    }

    function removeHistoryEntryById(entryId) {
      const updatedEntries = state.history.entries.filter((entry) => entry.id !== entryId);
      setHistoryEntries(updatedEntries);
      renderHistory();
    }

    function clearHistoryEntries() {
      setHistoryEntries([]);
      if (typeof localStorage !== 'undefined') {
        try {
          localStorage.removeItem(HISTORY_STORAGE_KEY);
        } catch (error) {
          console.error('Falha ao limpar histórico armazenado:', error);
        }
      }
      renderHistory();
    }

    function getHistoryEntryById(entryId) {
      return state.history.entries.find((entry) => entry.id === entryId) || null;
    }

    async function persistHistoryEntry(blob, durationInSeconds, script) {
      try {
        const audioUrl = await blobToDataUrl(blob);
        const uniqueId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        const newEntry = {
          id: uniqueId,
          createdAt: new Date().toISOString(),
          language: state.currentLanguage,
          duration: durationInSeconds,
          settings: { ...state.audio.settings },
          audioUrl,
          fileName: buildAudioFileName(state.audio.settings),
          script
        };
        addHistoryEntry(newEntry);
      } catch (error) {
        console.error('Falha ao registrar entrada do histórico de áudio:', error);
      }
    }

    function initializeHistory() {
      const storedEntries = loadHistoryFromStorage();
      state.history.entries = storedEntries;
      renderHistory();
    }

    function updateOutputStatus() {
      const localeTexts = translations[state.currentLanguage];
      if (state.manualOverride) {
        outputStatus.textContent = localeTexts.outputManual;
      } else if (state.lastGeneratedValues) {
        outputStatus.textContent = localeTexts.outputGenerated;
      } else {
        outputStatus.textContent = localeTexts.outputHelper;
      }
    }

    function updateAudioStatusMessage() {
      const localeTexts = translations[state.currentLanguage];
      const audioTexts = localeTexts.audio;
      const statusKey = state.audio.status;
      audioStatus.textContent = audioTexts.status[statusKey] || '';
    }

    function updateAudioValueOutput(key) {
      const target = audioValueElements[key];
      if (!target) {
        return;
      }

      const locale = state.currentLanguage;
      const controlTexts = translations[locale].audio.controls;
      let formattedValue = '';

      if (key === 'speed') {
        formattedValue = `${new Intl.NumberFormat(locale, { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(state.audio.settings.speed)}${controlTexts.speed.unit}`;
      } else if (key === 'volume') {
        formattedValue = new Intl.NumberFormat(locale, { style: 'percent', minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(state.audio.settings.volume);
      } else if (key === 'pause') {
        formattedValue = `${new Intl.NumberFormat(locale, { minimumFractionDigits: 1, maximumFractionDigits: 1 }).format(state.audio.settings.pause)} ${controlTexts.pause.unit}`;
      }

      target.textContent = formattedValue;

      const input = audioInputs[key];
      if (input) {
        input.setAttribute('aria-valuetext', formattedValue);
      }
    }

    function updateAudioValueOutputs() {
      Object.keys(audioValueElements).forEach(updateAudioValueOutput);
    }

    function resetAudioObjectUrl() {
      if (state.audio.objectUrl) {
        URL.revokeObjectURL(state.audio.objectUrl);
        state.audio.objectUrl = null;
      }
    }

    function resetAudioPreview() {
      resetAudioObjectUrl();
      state.audio.blob = null;
      state.audio.needsRegeneration = false;
      audioPlayer.pause();
      audioPlayer.removeAttribute('src');
      audioPlayer.load();
      audioDownloadButton.disabled = true;
    }

    function updateAudioActionsState() {
      audioGenerateButton.disabled = state.audio.isProcessing || !state.audio.hasScript;
      const disableDownload =
        state.audio.isProcessing ||
        !state.audio.blob ||
        state.audio.needsRegeneration;
      audioDownloadButton.disabled = disableDownload;
    }

    function setAudioStatus(statusKey) {
      state.audio.status = statusKey;
      updateAudioStatusMessage();
    }

    function applyTranslations(language) {
      const localeTexts = translations[language];
      document.documentElement.lang = language;
      document.title = localeTexts.pageTitle;
      languageSelect.value = language;

      titleElement.textContent = localeTexts.appTitle;
      subtitleElement.textContent = localeTexts.appSubtitle;
      languageLabel.textContent = localeTexts.languageLabel;
      languageHelper.textContent = localeTexts.languageHelper;
      formLegend.textContent = localeTexts.formLegend;
      formDescription.textContent = localeTexts.formDescription;
      outputLabel.textContent = localeTexts.outputLabel;
      scriptOutput.placeholder = localeTexts.outputPlaceholder;
      generateButton.textContent = localeTexts.actions.generate;
      editButton.textContent = localeTexts.actions.edit;

      const fieldTranslations = getFieldTranslations(language);
      cityInput.labels[0].textContent = fieldTranslations.city.label;
      cityInput.placeholder = fieldTranslations.city.placeholder;
      audienceInput.labels[0].textContent = fieldTranslations.audience.label;
      audienceInput.placeholder = fieldTranslations.audience.placeholder;
      highlightInput.labels[0].textContent = fieldTranslations.highlight.label;
      highlightInput.placeholder = fieldTranslations.highlight.placeholder;
      ctaInput.labels[0].textContent = fieldTranslations.cta.label;
      ctaInput.placeholder = fieldTranslations.cta.placeholder;

      languageSelect.querySelectorAll('[data-i18n-option]').forEach((option) => {
        const key = option.getAttribute('data-i18n-option');
        const label = localeTexts.languageNames[key];
        if (label) {
          option.textContent = label;
        }
      });

      const audioTexts = localeTexts.audio;
      audioTitle.textContent = audioTexts.title;
      audioDescription.textContent = audioTexts.description;
      audioGenerateButton.textContent = audioTexts.actions.preview;
      audioGenerateButton.title = audioTexts.actions.previewTooltip;
      audioDownloadButton.textContent = audioTexts.actions.download;
      audioDownloadButton.title = audioTexts.actions.downloadTooltip;

      ['speed', 'volume', 'pause'].forEach((key) => {
        if (audioLabels[key]) {
          audioLabels[key].textContent = audioTexts.controls[key].label;
        }
        if (audioHelpers[key]) {
          audioHelpers[key].textContent = audioTexts.controls[key].helper;
        }
        if (audioInputs[key]) {
          audioInputs[key].title = audioTexts.controls[key].tooltip;
          audioInputs[key].setAttribute('aria-label', audioTexts.controls[key].label);
        }
      });

      const historyTexts = localeTexts.history;
      if (historyTitle) {
        historyTitle.textContent = historyTexts.title;
      }
      if (historyDescription) {
        historyDescription.textContent = historyTexts.description;
      }
      if (historyClearButton) {
        historyClearButton.textContent = historyTexts.actions.clear;
        historyClearButton.title = historyTexts.actions.clear;
      }

      updateOutputStatus();
      updateAudioValueOutputs();
      updateAudioStatusMessage();
      renderHistory();
    }

    function handleFormSubmit(event) {
      event.preventDefault();

      const values = {
        city: cityInput.value.trim(),
        audience: audienceInput.value.trim(),
        highlight: highlightInput.value.trim(),
        cta: ctaInput.value.trim()
      };

      if (!values.city || !values.audience || !values.highlight || !values.cta) {
        return;
      }

      const script = composeScript(values, state.currentLanguage);
      scriptOutput.value = script;
      scriptOutput.readOnly = true;
      state.lastGeneratedValues = values;
      state.manualOverride = false;
      editButton.disabled = false;
      updateOutputStatus();
      scriptOutput.focus();
      scriptOutput.setSelectionRange(scriptOutput.value.length, scriptOutput.value.length);
      handleScriptContentChange();
    }

    function handleLanguageChange(event) {
      const newLanguage = event.target.value;
      if (!translations[newLanguage]) {
        return;
      }
      state.currentLanguage = newLanguage;
      applyTranslations(newLanguage);

      if (state.lastGeneratedValues && !state.manualOverride) {
        const regeneratedScript = composeScript(state.lastGeneratedValues, newLanguage);
        scriptOutput.value = regeneratedScript;
        scriptOutput.readOnly = true;
        handleScriptContentChange();
      }
    }

    function enableManualEditing() {
      scriptOutput.readOnly = false;
      scriptOutput.focus();
      editButton.disabled = true;
      state.manualOverride = true;
      updateOutputStatus();
    }

    function handleScriptContentChange() {
      resetAudioPreview();
      const hasContent = scriptOutput.value.trim().length > 0;
      state.audio.hasScript = hasContent;
      setAudioStatus(hasContent ? 'idle' : 'empty');
      updateAudioActionsState();
    }

    async function generateAudio(script, settings) {
      const AudioContextConstructor = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextConstructor) {
        throw new Error('AudioContext is not supported in this browser.');
      }

      const audioContext = new AudioContextConstructor();
      try {
        const sampleRate = audioContext.sampleRate;
        const chunks = script
          .split(/\n\s*\n/)
          .map((chunk) => chunk.trim())
          .filter(Boolean);

        if (!chunks.length) {
          throw new Error('No script content available to generate audio.');
        }

        const chunkBuffers = chunks.map((text, index) => {
          const words = text.split(/\s+/).filter(Boolean);
          const duration = Math.max(0.8, words.length * 0.18);
          const frameCount = Math.round(duration * sampleRate);
          const buffer = audioContext.createBuffer(1, frameCount, sampleRate);
          const data = buffer.getChannelData(0);
          const baseFrequency = 180 + index * 40 + Math.min(320, text.length * 2);
          const fadeSamples = Math.min(Math.round(sampleRate * 0.02), Math.floor(frameCount / 2));
          const amplitude = 0.18;

          for (let i = 0; i < frameCount; i += 1) {
            let sample = Math.sin((2 * Math.PI * baseFrequency * i) / sampleRate);
            if (i < fadeSamples) {
              sample *= i / fadeSamples;
            } else if (i >= frameCount - fadeSamples) {
              sample *= (frameCount - i) / fadeSamples;
            }
            data[i] = sample * amplitude;
          }

          return buffer;
        });

        const pauseFrameCount = Math.max(0, Math.round(settings.pause * sampleRate));
        const totalFrames = chunkBuffers.reduce((sum, buffer) => sum + buffer.length, 0) + Math.max(0, pauseFrameCount * (chunkBuffers.length - 1));
        const outputBuffer = audioContext.createBuffer(1, totalFrames, sampleRate);
        const outputData = outputBuffer.getChannelData(0);
        let offset = 0;

        chunkBuffers.forEach((buffer, index) => {
          outputData.set(buffer.getChannelData(0), offset);
          offset += buffer.length;
          if (index < chunkBuffers.length - 1) {
            offset += pauseFrameCount;
          }
        });

        const previewBlob = audioBufferToWave(outputBuffer, sampleRate, { volume: 1 });
        const downloadBuffer = settings.speed === 1 ? outputBuffer : resampleBuffer(audioContext, outputBuffer, settings.speed);
        const downloadBlob = audioBufferToWave(downloadBuffer, sampleRate, settings);
        const durationSeconds = downloadBuffer.length / sampleRate;

        return {
          previewBlob,
          downloadBlob,
          duration: durationSeconds
        };
      } finally {
        await audioContext.close();
      }
    }

    function audioBufferToWave(buffer, sampleRate, settings) {
      const channelData = buffer.getChannelData(0);
      const frameCount = buffer.length;
      const bytesPerSample = 2;
      const blockAlign = bytesPerSample;
      const dataLength = frameCount * bytesPerSample;
      const bufferLength = 44 + dataLength;
      const arrayBuffer = new ArrayBuffer(bufferLength);
      const view = new DataView(arrayBuffer);

      function writeString(offset, string) {
        for (let i = 0; i < string.length; i += 1) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      function floatTo16BitPCM(offset, input) {
        for (let i = 0; i < input.length; i += 1, offset += 2) {
          let sample = Math.max(-1, Math.min(1, input[i] * settings.volume));
          sample = sample < 0 ? sample * 0x8000 : sample * 0x7fff;
          view.setInt16(offset, sample, true);
        }
      }

      writeString(0, 'RIFF');
      view.setUint32(4, 36 + dataLength, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bytesPerSample * 8, true);
      writeString(36, 'data');
      view.setUint32(40, dataLength, true);
      floatTo16BitPCM(44, channelData);

      return new Blob([arrayBuffer], { type: 'audio/wav' });
    }

    function resampleBuffer(audioContext, buffer, speed) {
      const sourceData = buffer.getChannelData(0);
      const targetLength = Math.max(1, Math.round(sourceData.length / speed));
      const resampledBuffer = audioContext.createBuffer(1, targetLength, buffer.sampleRate);
      const targetData = resampledBuffer.getChannelData(0);

      for (let i = 0; i < targetLength; i += 1) {
        const sourceIndex = i * speed;
        const indexLower = Math.floor(sourceIndex);
        const indexUpper = Math.min(sourceData.length - 1, Math.ceil(sourceIndex));
        const weight = sourceIndex - indexLower;
        const lowerSample = sourceData[indexLower];
        const upperSample = sourceData[indexUpper];
        targetData[i] = lowerSample + (upperSample - lowerSample) * weight;
      }

      return resampledBuffer;
    }

    async function handleAudioGeneration() {
      if (state.audio.isProcessing || !state.audio.hasScript) {
        return;
      }

      const script = scriptOutput.value.trim();
      if (!script) {
        setAudioStatus('empty');
        return;
      }

      state.audio.isProcessing = true;
      state.audio.needsRegeneration = false;
      setAudioStatus('generating');
      updateAudioActionsState();

      try {
        const { previewBlob, downloadBlob, duration } = await generateAudio(script, state.audio.settings);
        resetAudioObjectUrl();
        state.audio.blob = downloadBlob;
        state.audio.objectUrl = URL.createObjectURL(previewBlob);
        audioPlayer.src = state.audio.objectUrl;
        audioPlayer.playbackRate = state.audio.settings.speed;
        audioPlayer.volume = state.audio.settings.volume;
        audioPlayer.load();
        audioPlayer.currentTime = 0;
        state.audio.needsRegeneration = false;
        setAudioStatus('ready');
        await persistHistoryEntry(downloadBlob, duration, script);
      } catch (error) {
        console.error('Erro ao gerar áudio:', error);
        if (state.audio.blob) {
          state.audio.needsRegeneration = true;
          setAudioStatus('needsRegeneration');
        } else {
          setAudioStatus('error');
        }
      } finally {
        state.audio.isProcessing = false;
        updateAudioActionsState();
      }
    }

    function handleAudioDownload() {
      if (state.audio.isProcessing || !state.audio.blob || state.audio.needsRegeneration) {
        return;
      }

      const url = URL.createObjectURL(state.audio.blob);
      const fileName = buildAudioFileName(state.audio.settings);
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = fileName;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      URL.revokeObjectURL(url);
    }

    function handleAudioInputChange(event) {
      const key = event.target.getAttribute('data-audio-input');
      if (!key || !(key in state.audio.settings)) {
        return;
      }

      const newValue = parseFloat(event.target.value);
      if (!Number.isNaN(newValue)) {
        state.audio.settings[key] = newValue;
      }

      updateAudioValueOutput(key);

      if (key === 'speed' && state.audio.blob) {
        audioPlayer.playbackRate = state.audio.settings.speed;
      }
      if (key === 'volume' && state.audio.blob) {
        audioPlayer.volume = state.audio.settings.volume;
      }

      if (state.audio.blob) {
        state.audio.needsRegeneration = true;
        setAudioStatus('needsRegeneration');
      } else if (state.audio.hasScript) {
        setAudioStatus('idle');
      }

      updateAudioActionsState();
    }

    function handleHistoryListClick(event) {
      if (!historyList) {
        return;
      }

      const button = event.target.closest('button[data-history-action]');
      if (!button) {
        return;
      }

      const action = button.getAttribute('data-history-action');
      const entryId = button.getAttribute('data-history-id');
      if (!action || !entryId) {
        return;
      }

      const entry = getHistoryEntryById(entryId);
      if (!entry) {
        return;
      }

      if (action === 'play') {
        const audioElement = historyList.querySelector(`[data-history-audio="${entryId}"]`);
        if (!audioElement) {
          return;
        }
        if (audioElement.src !== entry.audioUrl) {
          audioElement.src = entry.audioUrl;
        }
        audioElement.hidden = false;
        audioElement.playbackRate = entry?.settings?.speed ?? 1;
        audioElement.volume = entry?.settings?.volume ?? 1;
        audioElement.currentTime = 0;
        const playPromise = audioElement.play();
        if (playPromise && typeof playPromise.catch === 'function') {
          playPromise.catch(() => {});
        }
      } else if (action === 'download') {
        const anchor = document.createElement('a');
        anchor.href = entry.audioUrl;
        anchor.download = entry.fileName || buildAudioFileName(entry.settings || {});
        document.body.append(anchor);
        anchor.click();
        document.body.removeChild(anchor);
      } else if (action === 'remove') {
        const audioElement = historyList.querySelector(`[data-history-audio="${entryId}"]`);
        if (audioElement) {
          audioElement.pause();
        }
        removeHistoryEntryById(entryId);
      }
    }

    function handleHistoryClear() {
      if (!state.history.entries.length) {
        return;
      }

      if (!historyList) {
        return;
      }

      historyList.querySelectorAll('audio[data-history-audio]').forEach((audioElement) => {
        audioElement.pause();
      });

      clearHistoryEntries();
    }

    form.addEventListener('submit', handleFormSubmit);
    languageSelect.addEventListener('change', handleLanguageChange);
    editButton.addEventListener('click', enableManualEditing);
    scriptOutput.addEventListener('input', handleScriptContentChange);
    Object.values(audioInputs).forEach((input) => {
      input.addEventListener('input', handleAudioInputChange);
    });
    audioGenerateButton.addEventListener('click', handleAudioGeneration);
    audioDownloadButton.addEventListener('click', handleAudioDownload);
    if (historyList) {
      historyList.addEventListener('click', handleHistoryListClick);
    }
    if (historyClearButton) {
      historyClearButton.addEventListener('click', handleHistoryClear);
    }

    initializeHistory();
    applyTranslations(state.currentLanguage);
    updateAudioActionsState();
  </script>
</body>
</html>
