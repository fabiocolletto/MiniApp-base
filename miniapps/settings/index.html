<!DOCTYPE html>
<html lang="pt-BR" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniApp - Configurações do Sistema</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Sharp" rel="stylesheet">

    <link rel="stylesheet" href="../../docs/miniapp-global.css">

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@emotion/react@11.11.1/dist/emotion-react.umd.min.js"></script>
    <script crossorigin src="https://unpkg.com/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>
    <script crossorigin src="https://unpkg.com/@mui/material@5.15.14/umd/material-ui.production.min.js"></script>
    <script src="../../docs/components/app-shared-ui.js"></script>
    <script src="../../docs/components/app-modal-context.js"></script>
    <script type="module" src="../../docs/components/app-shared-footer.js"></script>

    <meta name="theme-color" content="#020617">
</head>
<body class="miniapp-shell">
    <main id="settings-root" class="miniapp-stage"></main>

    <app-shared-footer show-settings="true" active-tab="settings" state="collapsed"></app-shared-footer>

    <script type="module">
        import {
            LANGUAGE_LABELS,
            REFRESH_INTERVAL,
            resolveLanguageLabel,
            resolveThemeLabel,
            fetchStorageEstimate,
            formatBytes,
            getMemoryStatus,
            getStoredPreferences,
            syncPreferences,
        } from './config-control.js';

        const ReactLib = window.React;
        const ReactDOMLib = window.ReactDOM;
        const Material = window.MaterialUI;
        const { AppCard, AppButton, AppSection } = window.AppUI;
        const { AppModalProvider, useAppModal } = window.AppModalContext;

        if (!ReactLib || !ReactDOMLib || !Material || !AppCard || !AppModalProvider) {
            throw new Error('Dependências essenciais não foram carregadas para o MiniApp de Configurações.');
        }

        const {
            useCallback,
            useEffect,
            useMemo,
            useRef,
            useState,
            Fragment,
        } = ReactLib;
        const {
            ThemeProvider,
            createTheme,
            CssBaseline,
            Alert,
            Button,
            Avatar,
            Box,
            Chip,
            Container,
            Divider,
            FormControl,
            FormControlLabel,
            FormLabel,
            Grid,
            LinearProgress,
            List,
            ListItem,
            ListItemText,
            Radio,
            RadioGroup,
            Stack,
            TextField,
            Typography,
        } = Material;

        const MOCK_USER = {
            name: 'Fernanda Souza',
            email: 'fernanda.souza@5horas.io',
            role: 'Administrador',
            locale: 'Brasil',
        };

        const PAYMENT_SNAPSHOT = {
            activeSubscriptions: 3,
            nextCharge: {
                'pt-BR': '05 Mar, 08h00',
                'en-US': 'Mar 5, 8:00 AM',
                'es-ES': '05 Mar, 08:00',
            },
            monthlyValue: 'R$ 89,90',
            highlight: 'Mercado Pago - Plano Pro',
            note: {
                'pt-BR': 'Renovação automática agendada para 05/03 às 08h00.',
                'en-US': 'Auto-renewal scheduled for 03/05 at 8:00 AM.',
                'es-ES': 'Renovación automática programada para el 05/03 a las 08:00.',
            },
        };

        const LOCALE_COPY = Object.freeze({
            'pt-BR': {
                hero: {
                    overline: 'MiniApp Configurações',
                    title: 'Painel de preferências globais',
                    description: 'Centralize o perfil, pagamentos e preferências transmitidas para todos os MiniApps.',
                },
                userCard: {
                    subtitle: 'Dados do usuário',
                    categoryLabel: 'Categoria',
                    languageLabel: 'Idioma preferencial',
                    localeLabel: 'Localidade',
                    editAction: 'Editar',
                    dialogTitle: 'Editar dados do usuário',
                    form: {
                        name: 'Nome completo',
                        email: 'E-mail',
                        role: 'Função',
                        locale: 'Localidade',
                    },
                    cancel: 'Cancelar',
                    save: 'Salvar',
                    success: 'Perfil atualizado com sucesso.',
                },
                paymentsCard: {
                    title: 'Pagamentos e assinaturas',
                    subtitle: 'Resumo financeiro',
                    helper: 'Snapshot do MiniApp de Pagamentos antes de abrir o painel dedicado.',
                    metrics: {
                        activeSubscriptions: 'Assinaturas ativas',
                        nextCharge: 'Próximo ciclo',
                        monthlyValue: 'Valor mensal',
                    },
                    highlightLabel: 'Pagamento destacado',
                    buttons: {
                        primary: 'Abrir MiniApp de Pagamentos',
                        secondary: 'Histórico completo',
                    },
                },
                preferencesCard: {
                    title: 'Preferências globais',
                    subtitle: 'MiniSystems',
                    helper: 'As escolhas são transmitidas automaticamente para todo o shell.',
                    themeLegend: 'Tom da interface',
                    languageLegend: 'Idioma principal',
                    appliedTheme: 'Tema aplicado',
                    appliedLanguage: 'Idioma aplicado',
                    alertSynced: 'Preferências enviadas ao shell às {time}.',
                    alertFromDevice: 'Preferências carregadas deste dispositivo.',
                },
                memory: {
                    sectionTitle: 'Monitoramento de memória',
                    sectionDescription: 'Acompanhe o estado do IndexedDB sem sair do MiniApp Configurações.',
                    cardTitle: 'Memória local',
                    cardSubtitle: 'IndexedDB',
                    helper: 'Resumo compacto do armazenamento no dispositivo.',
                    detailButton: 'Ver detalhes',
                    statusDescriptor: 'Estado do IndexedDB',
                    freeLabel: 'Memória livre',
                    dialogTitle: 'Uso detalhado do IndexedDB',
                    dialogDescription: 'As métricas abaixo utilizam a API StorageManager.estimate().',
                    dialogFields: {
                        percentage: 'Percentual ocupado',
                        quota: 'Capacidade total',
                        usage: 'Uso calculado',
                        free: 'Memória livre',
                        updatedAt: 'Última atualização',
                    },
                    alertHint: 'Estável: < 60%, Atenção: 60-80%, Crítico: > 80% da cota.',
                    closeButton: 'Fechar',
                    statusLabels: {
                        collecting: 'Coletando dados...',
                        stable: 'Estável',
                        attention: 'Atenção',
                        critical: 'Crítico',
                    },
                },
            },
            'en-US': {
                hero: {
                    overline: 'Settings miniapp',
                    title: 'Global preference hub',
                    description: 'Centralize profile, billing and the preferences broadcast to every MiniApp.',
                },
                userCard: {
                    subtitle: 'User data',
                    categoryLabel: 'Category',
                    languageLabel: 'Preferred language',
                    localeLabel: 'Location',
                    editAction: 'Edit',
                    dialogTitle: 'Edit user data',
                    form: {
                        name: 'Full name',
                        email: 'Email',
                        role: 'Role',
                        locale: 'Location',
                    },
                    cancel: 'Cancel',
                    save: 'Save',
                    success: 'Profile updated successfully.',
                },
                paymentsCard: {
                    title: 'Billing & subscriptions',
                    subtitle: 'Financial snapshot',
                    helper: 'Preview of the Payments miniapp before opening the dedicated panel.',
                    metrics: {
                        activeSubscriptions: 'Active subscriptions',
                        nextCharge: 'Next cycle',
                        monthlyValue: 'Monthly value',
                    },
                    highlightLabel: 'Featured payment',
                    buttons: {
                        primary: 'Open Payments MiniApp',
                        secondary: 'Full history',
                    },
                },
                preferencesCard: {
                    title: 'Global preferences',
                    subtitle: 'MiniSystems',
                    helper: 'Choices are automatically broadcast to the entire shell.',
                    themeLegend: 'Interface tone',
                    languageLegend: 'Primary language',
                    appliedTheme: 'Applied theme',
                    appliedLanguage: 'Applied language',
                    alertSynced: 'Preferences sent to the shell at {time}.',
                    alertFromDevice: 'Preferences loaded from this device.',
                },
                memory: {
                    sectionTitle: 'Memory monitoring',
                    sectionDescription: 'Track IndexedDB health without leaving the Settings miniapp.',
                    cardTitle: 'Local storage',
                    cardSubtitle: 'IndexedDB',
                    helper: 'Compact summary of the storage on this device.',
                    detailButton: 'See details',
                    statusDescriptor: 'IndexedDB status',
                    freeLabel: 'Free storage',
                    dialogTitle: 'IndexedDB usage details',
                    dialogDescription: 'The metrics below rely on the StorageManager.estimate() API.',
                    dialogFields: {
                        percentage: 'Occupation percentage',
                        quota: 'Total capacity',
                        usage: 'Calculated usage',
                        free: 'Free storage',
                        updatedAt: 'Last update',
                    },
                    alertHint: 'Stable: < 60%, Warning: 60-80%, Critical: > 80% of the quota.',
                    closeButton: 'Close',
                    statusLabels: {
                        collecting: 'Collecting data...',
                        stable: 'Stable',
                        attention: 'Warning',
                        critical: 'Critical',
                    },
                },
            },
            'es-ES': {
                hero: {
                    overline: 'MiniApp Configuraciones',
                    title: 'Panel de preferencias globales',
                    description: 'Centraliza el perfil, los pagos y las preferencias transmitidas a todos los MiniApps.',
                },
                userCard: {
                    subtitle: 'Datos del usuario',
                    categoryLabel: 'Categoría',
                    languageLabel: 'Idioma preferido',
                    localeLabel: 'Ubicación',
                    editAction: 'Editar',
                    dialogTitle: 'Editar datos del usuario',
                    form: {
                        name: 'Nombre completo',
                        email: 'Correo electrónico',
                        role: 'Función',
                        locale: 'Ubicación',
                    },
                    cancel: 'Cancelar',
                    save: 'Guardar',
                    success: 'Perfil actualizado correctamente.',
                },
                paymentsCard: {
                    title: 'Pagos y suscripciones',
                    subtitle: 'Resumen financiero',
                    helper: 'Snapshot del MiniApp de Pagos antes de abrir el panel dedicado.',
                    metrics: {
                        activeSubscriptions: 'Suscripciones activas',
                        nextCharge: 'Próximo ciclo',
                        monthlyValue: 'Valor mensual',
                    },
                    highlightLabel: 'Pago destacado',
                    buttons: {
                        primary: 'Abrir MiniApp de Pagos',
                        secondary: 'Historial completo',
                    },
                },
                preferencesCard: {
                    title: 'Preferencias globales',
                    subtitle: 'MiniSystems',
                    helper: 'Las elecciones se transmiten automáticamente a todo el shell.',
                    themeLegend: 'Tono de la interfaz',
                    languageLegend: 'Idioma principal',
                    appliedTheme: 'Tema aplicado',
                    appliedLanguage: 'Idioma aplicado',
                    alertSynced: 'Preferencias enviadas al shell a las {time}.',
                    alertFromDevice: 'Preferencias cargadas desde este dispositivo.',
                },
                memory: {
                    sectionTitle: 'Monitoreo de memoria',
                    sectionDescription: 'Sigue el estado de IndexedDB sin salir del MiniApp Configuraciones.',
                    cardTitle: 'Memoria local',
                    cardSubtitle: 'IndexedDB',
                    helper: 'Resumen compacto del almacenamiento en el dispositivo.',
                    detailButton: 'Ver detalles',
                    statusDescriptor: 'Estado de IndexedDB',
                    freeLabel: 'Memoria libre',
                    dialogTitle: 'Uso detallado de IndexedDB',
                    dialogDescription: 'Las métricas abajo utilizan la API StorageManager.estimate().',
                    dialogFields: {
                        percentage: 'Porcentaje ocupado',
                        quota: 'Capacidad total',
                        usage: 'Uso calculado',
                        free: 'Memoria libre',
                        updatedAt: 'Última actualización',
                    },
                    alertHint: 'Estable: < 60%, Atención: 60-80%, Crítico: > 80% de la cuota.',
                    closeButton: 'Cerrar',
                    statusLabels: {
                        collecting: 'Recopilando datos...',
                        stable: 'Estable',
                        attention: 'Atención',
                        critical: 'Crítico',
                    },
                },
            },
        });

        function getLocaleCopy(language) {
            return LOCALE_COPY[language] || LOCALE_COPY['pt-BR'];
        }

        const e = ReactLib.createElement;

        function useStorageEstimate() {
            const [snapshot, setSnapshot] = useState(() => ({
                quota: 0,
                usage: 0,
                status: getMemoryStatus(0, 0),
                timestamp: null,
            }));

            useEffect(() => {
                let mounted = true;
                async function refreshEstimate() {
                    const result = await fetchStorageEstimate();
                    if (!mounted) return;
                    setSnapshot({
                        ...result,
                        status: getMemoryStatus(result.usage, result.quota),
                        timestamp: new Date(),
                    });
                }
                refreshEstimate();
                const interval = setInterval(refreshEstimate, REFRESH_INTERVAL);
                return () => {
                    mounted = false;
                    clearInterval(interval);
                };
            }, []);

            return snapshot;
        }

        function MemoryStatusCard({ copy, language }) {
            const modal = useAppModal();
            const snapshot = useStorageEstimate();
            const status = snapshot.status;
            const freeBytes = Math.max(snapshot.quota - snapshot.usage, 0);
            const memoryCopy = copy;
            const statusLabel = (memoryCopy.statusLabels && memoryCopy.statusLabels[status.key]) || status.label;

            const openDetails = useCallback(() => {
                modal.openDialog({
                    title: memoryCopy.dialogTitle,
                    maxWidth: 'md',
                    content: () => e(
                        Stack,
                        { spacing: 3, sx: { py: 1 } },
                        e(Typography, { variant: 'body1' }, memoryCopy.dialogDescription),
                        e(
                            Box,
                            null,
                            e(Typography, { variant: 'overline', color: 'text.secondary' }, memoryCopy.dialogFields.percentage),
                            e(LinearProgress, {
                                variant: 'determinate',
                                value: status.percentage || 0,
                                sx: { mt: 1.5, height: 8, borderRadius: 999 },
                            })
                        ),
                        e(
                            Grid,
                            { container: true, spacing: 2 },
                            e(Grid, { item: true, xs: 12, sm: 6 },
                                e(Typography, { variant: 'body2', color: 'text.secondary' }, memoryCopy.dialogFields.quota),
                                e(Typography, { variant: 'h6' }, snapshot.quota ? formatBytes(snapshot.quota) : '--')
                            ),
                            e(Grid, { item: true, xs: 12, sm: 6 },
                                e(Typography, { variant: 'body2', color: 'text.secondary' }, memoryCopy.dialogFields.usage),
                                e(Typography, { variant: 'h6' }, snapshot.usage ? formatBytes(snapshot.usage) : '--')
                            ),
                            e(Grid, { item: true, xs: 12, sm: 6 },
                                e(Typography, { variant: 'body2', color: 'text.secondary' }, memoryCopy.dialogFields.free),
                                e(Typography, { variant: 'h6' }, snapshot.quota ? formatBytes(freeBytes) : '--')
                            ),
                            e(Grid, { item: true, xs: 12, sm: 6 },
                                e(Typography, { variant: 'body2', color: 'text.secondary' }, memoryCopy.dialogFields.updatedAt),
                                e(Typography, { variant: 'h6' }, snapshot.timestamp ? snapshot.timestamp.toLocaleTimeString(language || 'pt-BR') : '--')
                            ),
                        ),
                        e(Alert, { severity: 'info' }, memoryCopy.alertHint)
                    ),
                    actions: ({ closeDialog }) => e(Fragment, null,
                        e(Button, { onClick: closeDialog }, memoryCopy.closeButton)
                    ),
                });
            }, [modal, status.percentage, snapshot.quota, snapshot.timestamp, snapshot.usage, freeBytes, memoryCopy, language]);

            return e(
                AppCard,
                {
                    title: memoryCopy.cardTitle,
                    subtitle: memoryCopy.cardSubtitle,
                    helper: memoryCopy.helper,
                    actions: e(AppButton, { tone: 'secondary', onClick: openDetails }, memoryCopy.detailButton),
                    sx: { minHeight: 300 },
                },
                e(
                    Stack,
                    { spacing: 2 },
                    e(Typography, { variant: 'h3' }, snapshot.usage ? formatBytes(snapshot.usage) : '--'),
                    e(Stack, { direction: 'row', spacing: 1.5, alignItems: 'center' },
                        e(Chip, {
                            label: statusLabel,
                            color: status.variant === 'error' ? 'error' : status.variant === 'warning' ? 'warning' : 'success',
                        }),
                        e(Typography, { variant: 'body2', color: 'text.secondary' }, memoryCopy.statusDescriptor)
                    ),
                    e(LinearProgress, { variant: 'determinate', value: status.percentage || 0, sx: { height: 8, borderRadius: 999 } }),
                    e(Typography, { variant: 'body2', color: 'text.secondary' }, `${memoryCopy.freeLabel}: ${snapshot.quota ? formatBytes(freeBytes) : '--'}`)
                )
            );
        }

        function UserProfileForm({ defaultValue, onChange, copy }) {
            const [formState, setFormState] = useState(defaultValue);

            useEffect(() => {
                setFormState(defaultValue);
            }, [defaultValue]);

            const updateField = (field) => (event) => {
                const nextValue = { ...formState, [field]: event.target.value };
                setFormState(nextValue);
                if (typeof onChange === 'function') {
                    onChange(nextValue);
                }
            };

            return e(
                Stack,
                { spacing: 2, sx: { pt: 1 } },
                e(TextField, { label: copy.form.name, fullWidth: true, value: formState.name, onChange: updateField('name') }),
                e(TextField, { label: copy.form.email, fullWidth: true, value: formState.email, onChange: updateField('email') }),
                e(TextField, { label: copy.form.role, fullWidth: true, value: formState.role, onChange: updateField('role') }),
                e(TextField, { label: copy.form.locale, fullWidth: true, value: formState.locale, onChange: updateField('locale') })
            );
        }

        function UserProfileCard({ copy, language }) {
            const modal = useAppModal();
            const [user, setUser] = useState(MOCK_USER);
            const pendingProfile = useRef(user);

            const openEditor = useCallback(() => {
                pendingProfile.current = user;
                modal.openDialog({
                    title: copy.dialogTitle,
                    maxWidth: 'sm',
                    content: () => e(UserProfileForm, {
                        defaultValue: user,
                        onChange: (nextValue) => {
                            pendingProfile.current = nextValue;
                        },
                        copy,
                    }),
                    actions: ({ closeDialog }) => e(Fragment, null,
                        e(Button, { onClick: closeDialog }, copy.cancel),
                        e(Button, {
                            variant: 'contained',
                            onClick: () => {
                                setUser(pendingProfile.current);
                                modal.showSnackbar({ message: copy.success, severity: 'success' });
                                closeDialog();
                            },
                        }, copy.save)
                    ),
                });
            }, [modal, user, copy]);

            return e(
                AppCard,
                {
                    title: user.name,
                    subtitle: copy.subtitle,
                    helper: user.email,
                    actions: e(AppButton, { tone: 'secondary', onClick: openEditor }, copy.editAction),
                    sx: { minHeight: 300 },
                },
                e(
                    Stack,
                    { spacing: 2 },
                    e(Stack, { direction: 'row', spacing: 1.5, alignItems: 'center' },
                        e(Avatar, { children: user.name.slice(0, 1) }),
                        e('div', null,
                            e(Typography, { variant: 'body2', color: 'text.secondary' }, copy.categoryLabel),
                            e(Typography, { variant: 'h6' }, user.role)
                        )
                    ),
                    e(Divider, null),
                    e(List, { dense: true, disablePadding: true },
                        e(ListItem, { disableGutters: true },
                            e(ListItemText, { primary: copy.languageLabel, secondary: resolveLanguageLabel(language, language) })
                        ),
                        e(ListItem, { disableGutters: true },
                            e(ListItemText, { primary: copy.localeLabel, secondary: user.locale })
                        )
                    )
                )
            );
        }

        function PaymentsCard({ copy, language }) {
            const paymentsCopy = copy;
            return e(
                AppCard,
                {
                    title: paymentsCopy.title,
                    subtitle: paymentsCopy.subtitle,
                    helper: paymentsCopy.helper,
                    sx: { minHeight: 300 },
                },
                e(
                    Stack,
                    { spacing: 2.5 },
                    e(Grid, { container: true, spacing: 2 },
                        e(Grid, { item: true, xs: 12, sm: 4 },
                            e(Typography, { variant: 'body2', color: 'text.secondary' }, paymentsCopy.metrics.activeSubscriptions),
                            e(Typography, { variant: 'h5' }, PAYMENT_SNAPSHOT.activeSubscriptions)
                        ),
                        e(Grid, { item: true, xs: 12, sm: 4 },
                            e(Typography, { variant: 'body2', color: 'text.secondary' }, paymentsCopy.metrics.nextCharge),
                            e(Typography, { variant: 'h5' }, PAYMENT_SNAPSHOT.nextCharge[language] || PAYMENT_SNAPSHOT.nextCharge['pt-BR'])
                        ),
                        e(Grid, { item: true, xs: 12, sm: 4 },
                            e(Typography, { variant: 'body2', color: 'text.secondary' }, paymentsCopy.metrics.monthlyValue),
                            e(Typography, { variant: 'h5' }, PAYMENT_SNAPSHOT.monthlyValue)
                        )
                    ),
                    e(Box, { sx: { p: 2.5, borderRadius: 3, border: '1px solid', borderColor: 'divider' } },
                        e(Typography, { variant: 'overline', color: 'text.secondary' }, paymentsCopy.highlightLabel),
                        e(Typography, { variant: 'h6', sx: { mt: 0.5 } }, PAYMENT_SNAPSHOT.highlight),
                        e(Typography, { variant: 'body2', color: 'text.secondary', sx: { mt: 0.5 } }, PAYMENT_SNAPSHOT.note[language] || PAYMENT_SNAPSHOT.note['pt-BR'])
                    ),
                    e(Stack, { direction: { xs: 'column', sm: 'row' }, spacing: 1.5 },
                        e(AppButton, { tone: 'primary', component: 'a', href: '../payments/index.html' }, paymentsCopy.buttons.primary),
                        e(AppButton, { tone: 'subtle', component: 'a', href: '../payments/index.html#history' }, paymentsCopy.buttons.secondary)
                    )
                )
            );
        }

        function PreferencesCard({ preferences, onChange, lastSync, copy, language }) {
            const preferencesCopy = copy;
            const handleThemeChange = useCallback((event) => {
                onChange('theme', event.target.value);
            }, [onChange]);

            const handleLanguageChange = useCallback((event) => {
                onChange('language', event.target.value);
            }, [onChange]);

            const formattedSync = lastSync
                ? lastSync.toLocaleTimeString(language || 'pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
                : null;

            return e(
                AppCard,
                {
                    title: preferencesCopy.title,
                    subtitle: preferencesCopy.subtitle,
                    helper: preferencesCopy.helper,
                    sx: { minHeight: 300 },
                },
                e(
                    Stack,
                    { spacing: 3 },
                    e(FormControl, { component: 'fieldset' },
                        e(FormLabel, { component: 'legend' }, preferencesCopy.themeLegend),
                        e(RadioGroup, { row: true, value: preferences.theme, onChange: handleThemeChange },
                            e(FormControlLabel, { value: 'light', control: e(Radio, null), label: resolveThemeLabel('light', language) }),
                            e(FormControlLabel, { value: 'dark', control: e(Radio, null), label: resolveThemeLabel('dark', language) }),
                        )
                    ),
                    e(FormControl, { component: 'fieldset' },
                        e(FormLabel, { component: 'legend' }, preferencesCopy.languageLegend),
                        e(RadioGroup, { row: true, value: preferences.language, onChange: handleLanguageChange },
                            Object.keys(LANGUAGE_LABELS).map((value) => (
                                e(FormControlLabel, { key: value, value, control: e(Radio, null), label: resolveLanguageLabel(value, language) })
                            ))
                        )
                    ),
                    e(Divider, null),
                    e(Stack, { direction: { xs: 'column', sm: 'row' }, spacing: 2 },
                        e(Box, null,
                            e(Typography, { variant: 'overline', color: 'text.secondary' }, preferencesCopy.appliedTheme),
                            e(Typography, { variant: 'h6' }, resolveThemeLabel(preferences.theme, language))
                        ),
                        e(Box, null,
                            e(Typography, { variant: 'overline', color: 'text.secondary' }, preferencesCopy.appliedLanguage),
                            e(Typography, { variant: 'h6' }, resolveLanguageLabel(preferences.language, language))
                        )
                    ),
                    e(Alert, { severity: 'info' }, formattedSync
                        ? preferencesCopy.alertSynced.replace('{time}', formattedSync)
                        : preferencesCopy.alertFromDevice
                    )
                )
            );
        }

        function SettingsLayout() {
            const [preferences, setPreferences] = useState(() => {
                const stored = getStoredPreferences();
                syncPreferences(stored, { silent: true });
                return stored;
            });
            const [lastSyncedAt, setLastSyncedAt] = useState(null);
            const localeCopy = useMemo(() => getLocaleCopy(preferences.language), [preferences.language]);

            const handlePreferenceChange = useCallback((field, value) => {
                setPreferences((current) => {
                    if (current[field] === value) {
                        return current;
                    }
                    const next = { ...current, [field]: value };
                    syncPreferences(next, { silent: false });
                    setLastSyncedAt(new Date());
                    return next;
                });
            }, []);

            const themeMode = preferences.theme === 'light' ? 'light' : 'dark';
            const appTheme = useMemo(() => createTheme({
                palette: {
                    mode: themeMode,
                    primary: { main: '#f97316' },
                    secondary: { main: '#0ea5e9' },
                    background: {
                        default: themeMode === 'light' ? '#f3f4f6' : '#020617',
                        paper: themeMode === 'light' ? '#ffffff' : '#0f172a',
                    },
                },
                typography: {
                    fontFamily: '"Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
                },
                shape: { borderRadius: 24 },
            }), [themeMode]);

            return e(
                ThemeProvider,
                { theme: appTheme },
                e(CssBaseline, null),
                e(
                    AppModalProvider,
                    null,
                    e(
                        Box,
                        { className: 'miniapp-stage', sx: { flex: 1 } },
                        e(
                            Container,
                            { maxWidth: 'lg', sx: { py: { xs: 3, md: 5 }, display: 'flex', flexDirection: 'column', gap: 4 } },
                            e(
                                Stack,
                                { spacing: 1.25 },
                                e(Typography, { variant: 'overline', color: 'text.secondary' }, localeCopy.hero.overline),
                                e(Typography, { variant: 'h4', component: 'h1' }, localeCopy.hero.title),
                                e(Typography, { color: 'text.secondary' }, localeCopy.hero.description)
                            ),
                            e(
                                Grid,
                                { container: true, spacing: 2 },
                                e(Grid, { item: true, xs: 12, sm: 6, md: 4 }, e(UserProfileCard, { copy: localeCopy.userCard, language: preferences.language })),
                                e(Grid, { item: true, xs: 12, sm: 6, md: 4 }, e(PaymentsCard, { copy: localeCopy.paymentsCard, language: preferences.language })),
                                e(Grid, { item: true, xs: 12, sm: 6, md: 4 }, e(PreferencesCard, { preferences, onChange: handlePreferenceChange, lastSync: lastSyncedAt, copy: localeCopy.preferencesCard, language: preferences.language }))
                            ),
                            e(
                                AppSection,
                                { title: localeCopy.memory.sectionTitle, description: localeCopy.memory.sectionDescription },
                                e(Grid, { container: true, spacing: 2 },
                                    e(Grid, { item: true, xs: 12, sm: 6, md: 4 }, e(MemoryStatusCard, { copy: localeCopy.memory, language: preferences.language }))
                                )
                            )
                        )
                    )
                )
            );
        }

        ReactDOMLib.createRoot(document.getElementById('settings-root')).render(e(SettingsLayout));
    </script>
</body>
</html>
