/*! @license idb (simplified bundle) v7.1.1
 * Copyright (c) 2014â€“2023 Jake Archibald
 * Released under the MIT license
 * https://github.com/jakearchibald/idb
 */

const READONLY = 'readonly';
const READWRITE = 'readwrite';

function wrapRequest(request) {
  return new Promise((resolve, reject) => {
    if (!request) {
      resolve(undefined);
      return;
    }

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

function trackTransaction(tx) {
  return new Promise((resolve, reject) => {
    if (!tx) {
      resolve();
      return;
    }

    tx.oncomplete = () => resolve();
    tx.onabort = () => reject(tx.error);
    tx.onerror = () => reject(tx.error);
  });
}

function wrapIndex(index) {
  return {
    get name() {
      return index.name;
    },
    get keyPath() {
      return index.keyPath;
    },
    get multiEntry() {
      return index.multiEntry;
    },
    get unique() {
      return index.unique;
    },
    get(query) {
      return wrapRequest(index.get(query));
    },
    getKey(query) {
      return wrapRequest(index.getKey(query));
    },
    getAll(query, count) {
      return wrapRequest(index.getAll(query, count));
    },
    getAllKeys(query, count) {
      return wrapRequest(index.getAllKeys(query, count));
    },
    count(query) {
      return wrapRequest(index.count(query));
    },
  };
}

function wrapStore(store) {
  return {
    get name() {
      return store.name;
    },
    get keyPath() {
      return store.keyPath;
    },
    get indexNames() {
      return store.indexNames;
    },
    index(name) {
      return wrapIndex(store.index(name));
    },
    get(query) {
      return wrapRequest(store.get(query));
    },
    getKey(query) {
      return wrapRequest(store.getKey(query));
    },
    getAll(query, count) {
      return wrapRequest(store.getAll(query, count));
    },
    getAllKeys(query, count) {
      return wrapRequest(store.getAllKeys(query, count));
    },
    put(value, key) {
      return wrapRequest(store.put(value, key));
    },
    add(value, key) {
      return wrapRequest(store.add(value, key));
    },
    delete(key) {
      return wrapRequest(store.delete(key));
    },
    clear() {
      return wrapRequest(store.clear());
    },
    count(query) {
      return wrapRequest(store.count(query));
    },
  };
}

function wrapTransaction(tx) {
  const store = tx.objectStoreNames.length === 1 ? wrapStore(tx.objectStore(tx.objectStoreNames[0])) : undefined;

  const done = trackTransaction(tx);
  return {
    get store() {
      return store;
    },
    get mode() {
      return tx.mode;
    },
    objectStore(name) {
      return wrapStore(tx.objectStore(name));
    },
    abort() {
      tx.abort();
    },
    done,
    raw: tx,
  };
}

function runStoreOperation(db, storeName, mode, operation) {
  const tx = db.transaction(storeName, mode);
  const store = tx.objectStore(storeName);
  const request = operation(store);

  return Promise.all([wrapRequest(request), trackTransaction(tx)]).then(([result]) => result);
}

function runIndexOperation(db, storeName, indexName, mode, operation) {
  const tx = db.transaction(storeName, mode);
  const store = tx.objectStore(storeName);
  const index = store.index(indexName);
  const request = operation(index, store);

  return Promise.all([wrapRequest(request), trackTransaction(tx)]).then(([result]) => result);
}

function wrapDatabase(db) {
  return {
    get name() {
      return db.name;
    },
    get version() {
      return db.version;
    },
    get objectStoreNames() {
      return db.objectStoreNames;
    },
    close() {
      db.close();
    },
    createObjectStore(...args) {
      return db.createObjectStore(...args);
    },
    deleteObjectStore(...args) {
      return db.deleteObjectStore(...args);
    },
    transaction(storeNames, mode = READONLY, options) {
      const tx = db.transaction(storeNames, mode, options);
      return wrapTransaction(tx);
    },
    get(storeName, key) {
      return runStoreOperation(db, storeName, READONLY, (store) => store.get(key));
    },
    getKey(storeName, key) {
      return runStoreOperation(db, storeName, READONLY, (store) => store.getKey(key));
    },
    getAll(storeName, query, count) {
      return runStoreOperation(db, storeName, READONLY, (store) => store.getAll(query, count));
    },
    getAllKeys(storeName, query, count) {
      return runStoreOperation(db, storeName, READONLY, (store) => store.getAllKeys(query, count));
    },
    put(storeName, value, key) {
      return runStoreOperation(db, storeName, READWRITE, (store) => store.put(value, key));
    },
    add(storeName, value, key) {
      return runStoreOperation(db, storeName, READWRITE, (store) => store.add(value, key));
    },
    delete(storeName, key) {
      return runStoreOperation(db, storeName, READWRITE, (store) => store.delete(key));
    },
    clear(storeName) {
      return runStoreOperation(db, storeName, READWRITE, (store) => store.clear());
    },
    count(storeName, query) {
      return runStoreOperation(db, storeName, READONLY, (store) => store.count(query));
    },
    getFromIndex(storeName, indexName, query) {
      return runIndexOperation(db, storeName, indexName, READONLY, (index) => index.get(query));
    },
    getAllFromIndex(storeName, indexName, query, count) {
      return runIndexOperation(db, storeName, indexName, READONLY, (index) => index.getAll(query, count));
    },
    countFromIndex(storeName, indexName, query) {
      return runIndexOperation(db, storeName, indexName, READONLY, (index) => index.count(query));
    },
  };
}

export function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
  return new Promise((resolve, reject) => {
    if (typeof indexedDB === 'undefined') {
      reject(new Error('IndexedDB is not available in this environment.'));
      return;
    }

    const request = indexedDB.open(name, version);

    request.onupgradeneeded = (event) => {
      const db = request.result;
      const wrapped = wrapDatabase(db);
      const tx = wrapTransaction(request.transaction);
      if (typeof upgrade === 'function') {
        upgrade(wrapped, event.oldVersion, event.newVersion, tx);
      }
    };

    request.onblocked = (event) => {
      if (typeof blocked === 'function') {
        blocked(event);
      }
    };

    request.onerror = () => {
      reject(request.error ?? new Error('Failed to open IndexedDB database.'));
    };

    request.onsuccess = () => {
      const db = request.result;

      if (typeof blocking === 'function') {
        db.onversionchange = (event) => {
          blocking(event);
        };
      }

      if (typeof terminated === 'function') {
        db.onclose = (event) => {
          terminated(event);
        };
      }

      resolve(wrapDatabase(db));
    };
  });
}

export function deleteDB(name, { blocked } = {}) {
  return new Promise((resolve, reject) => {
    if (typeof indexedDB === 'undefined') {
      resolve();
      return;
    }

    const request = indexedDB.deleteDatabase(name);

    request.onblocked = (event) => {
      if (typeof blocked === 'function') {
        blocked(event);
      }
    };

    request.onerror = () => {
      reject(request.error ?? new Error('Failed to delete IndexedDB database.'));
    };

    request.onsuccess = () => {
      resolve();
    };
  });
}

export function unwrap(value) {
  return value && value.raw ? value.raw : value;
}

export function wrap(value) {
  if (!value) {
    return value;
  }

  if (value instanceof IDBDatabase) {
    return wrapDatabase(value);
  }
  if (value instanceof IDBTransaction) {
    return wrapTransaction(value);
  }
  if (value instanceof IDBObjectStore) {
    return wrapStore(value);
  }
  if (value instanceof IDBIndex) {
    return wrapIndex(value);
  }

  return value;
}
