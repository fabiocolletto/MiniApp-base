<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gestor de Catálogo de MiniApps (Admin)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Estilos customizados para o Tailwind e fontes */
    body { font-family: 'Inter', sans-serif; background-color: #f7f9fc; }
    .loading-spinner { border-top-color: #3b82f6; }
    
    /* Estilo para todas as tabelas e células */
    .summary-table th, .summary-table td, .preview-table-container th, .preview-table-container td {
        padding: 12px 16px;
        border: 1px solid #e5e7eb;
        text-align: left;
        font-size: 0.875rem; /* text-sm */
    }
    
    /* Regras CRUCIAIS para prevenir expansão de coluna por texto longo */
    .summary-table td, .preview-table-container td {
        white-space: nowrap; /* Não quebra linha */
        overflow: hidden; /* Esconde o excesso */
        text-overflow: ellipsis; /* Adiciona "..." no final */
        max-width: 200px; /* Largura máxima para a célula de dados */
    }
    
    /* Estilo específico para células editáveis */
    .editable-cell {
        cursor: text;
        transition: background-color 0.1s;
    }
    .editable-cell:focus {
        outline: 2px solid #3b82f6; /* Ring azul ao focar */
        background-color: #fff;
    }
    .data-edited {
        background-color: #ffedd5; /* Laranja claro para indicar edição pendente */
    }
    
    .summary-table th, .preview-table-container th { 
        background-color: #f3f4f6; 
        font-weight: 600; 
        color: #1f2937; 
    }
    .summary-table, .preview-table-container table { 
        width: 100%; 
        border-collapse: collapse;
        border-radius: 0.5rem;
        overflow: hidden; 
    }
    /* Ths clicáveis para ordenação */
    .sortable-th {
        cursor: pointer;
    }

    /* Estilo para os botões de ação na tabela */
    .action-button {
        padding: 0.35rem 0.75rem;
        font-size: 0.75rem;
        font-weight: 500;
        margin-left: 0.5rem;
        border-radius: 0.375rem;
        transition: background-color 0.15s ease;
    }
    /* Classe para esconder/mostrar o formulário */
    .hidden-form { display: none; }
    /* Adicionando um estilo visual para a linha selecionada na pré-visualização */
    .preview-table-container tr.selected {
        background-color: #f0f9ff;
    }

    body[data-theme="dark"] { background-color: #020617; color: #e2e8f0; }
    body[data-theme="dark"] .bg-white { background-color: #0f172a !important; color: #e2e8f0; }
    body[data-theme="dark"] .text-gray-800,
    body[data-theme="dark"] .text-gray-700,
    body[data-theme="dark"] .text-gray-600,
    body[data-theme="dark"] .text-gray-500 { color: #cbd5f5 !important; }
    body[data-theme="dark"] .border-gray-200,
    body[data-theme="dark"] .border-gray-300,
    body[data-theme="dark"] .border-gray-100 { border-color: #1e293b !important; }
    body[data-theme="dark"] .bg-gray-100,
    body[data-theme="dark"] .bg-gray-50 { background-color: #1e293b !important; }
    body[data-theme="dark"] .text-indigo-500,
    body[data-theme="dark"] .text-indigo-600,
    body[data-theme="dark"] .text-indigo-700 { color: #a5b4fc !important; }
    body[data-theme="dark"] .bg-green-100 { background-color: rgba(34, 197, 94, 0.25) !important; color: #bbf7d0 !important; }
    body[data-theme="dark"] .bg-yellow-100 { background-color: rgba(217, 119, 6, 0.3) !important; color: #fde68a !important; }
    body[data-theme="dark"] input,
    body[data-theme="dark"] textarea,
    body[data-theme="dark"] select { background-color: #0f172a; color: #f8fafc; border-color: #1e293b !important; }
    body[data-theme="dark"] input::placeholder,
    body[data-theme="dark"] textarea::placeholder { color: #94a3b8; }
    body[data-theme="dark"] .loading-spinner { border-color: #1e293b; border-top-color: #38bdf8; }
  </style>
  <link rel="stylesheet" href="../miniapp-base/style/styles.css" />
  <!-- Firebase Imports -->
  <script type="module">
    // --- Configuração e Variáveis Globais ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { DEFAULT_LOCALE, getDirection, getManagerMessages } from "../js/i18n.js";

    setLogLevel('Debug');

    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    let app, db, auth;
    let firebaseInitialized = false;

    // Armazenamento local dos dados importados
    const STORAGE_NAMESPACE = 'miniapp-catalog.admin';
    const STORAGE_KEYS = {
        activeItems: `${STORAGE_NAMESPACE}.activeItems`,
        sheetId: `${STORAGE_NAMESPACE}.sheetId`,
    };
    const SHELL_SHEET_KEY = 'miniapp-shell.sheetId';

    window.ACTIVE_MINIAPPS = {};
    window.CATALOG_PREVIEW_DATA = [];
    
    // Estado de ordenação da tabela ativa (Passo 3)
    let summarySortState = { key: 'name', direction: 'asc' }; 
    // Estado de ordenação da tabela de pré-visualização (Passo 2)
    let previewSortState = { key: 'name', direction: 'asc' }; 

    if (firebaseConfig) {
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            firebaseInitialized = true;
            window.db = db;
            window.auth = auth;
            window.appId = appId;
        } catch (e) {
            console.error("Erro ao inicializar Firebase:", e);
        }
    }
    
    // Referências de UI
    const statusMessage = document.getElementById('status-message');
    const managerHeading = document.getElementById('managerHeading');
    const managerTitleSpan = managerHeading ? managerHeading.querySelector('[data-manager-title]') : null;
    const managerBadge = document.getElementById('managerBadge');
    const managerSubtitle = document.getElementById('managerSubtitle');
    const configFormContainer = document.getElementById('config-form-container');
    const configStatusBar = document.getElementById('config-status-bar');
    const previewContainer = document.getElementById('preview-data-container');
    const summaryContainer = document.getElementById('loaded-summary-container');
    const sheetUrlInput = document.getElementById('sheetUrlInput');
    const importButton = document.getElementById('importCatalogButton');
    const testButton = document.getElementById('testSheetButton');

    let currentLocale = DEFAULT_LOCALE;
    let managerMessages = getManagerMessages(currentLocale);
    let currentStatusKey = 'initializing';
    let currentStatusRaw = managerMessages.status.initializing;
    let currentStatusContext = {};
    let statusObserver;
    let suppressStatusObserver = false;
    let currentPanelKey = null;
    let currentPanelContext = {};
    let currentPanelFallbackHtml = '';
    let currentPanelSummaryFallback = '';

    if (statusMessage) {
      statusObserver = new MutationObserver(() => {
        if (suppressStatusObserver) return;
        currentStatusRaw = statusMessage.textContent;
        currentStatusKey = null;
        currentStatusContext = {};
      });
      statusObserver.observe(statusMessage, { characterData: true, childList: true, subtree: true });
    }
    
    // --- FUNÇÕES DE PERSISTÊNCIA (fallback local) ---
    const DOCUMENT_ID = 'sheet_config';
    function getUserSettingsRef() { /* ... */ return null; }

    function formatTemplate(template, context = {}) {
        if (typeof template !== 'string') {
            return '';
        }
        return template.replace(/\{\{(.*?)\}\}/g, (_, rawKey) => {
            const trimmed = rawKey.trim();
            return Object.prototype.hasOwnProperty.call(context, trimmed) ? context[trimmed] : '';
        });
    }

    function enhanceContextForKey(key, context = {}) {
        if (!key) {
            return { ...context };
        }

        const enhanced = { ...context };

        if (key === 'linkChanged' || key === 'sheetRestored') {
            const stepKey = enhanced.stepKey || 'preview';
            const stepInfo = managerMessages.steps?.[stepKey] || {};
            enhanced.stepLabel = stepInfo.shortLabel || enhanced.stepLabel || 'Testar e Visualizar';
            enhanced.stepNumber = stepInfo.number || enhanced.stepNumber || '2';
        }

        if (key === 'importSummary') {
            enhanced.sectionNumber = enhanced.sectionNumber || '3';
        }

        return enhanced;
    }

    function setStatus(key, fallbackMessage, context = {}) {
        if (!statusMessage) return;
        suppressStatusObserver = true;
        const effectiveContext = enhanceContextForKey(key, context);
        const template = key ? managerMessages.status[key] : null;
        const resolved = template ? formatTemplate(template, effectiveContext) : fallbackMessage;
        statusMessage.textContent = resolved;
        currentStatusKey = key;
        currentStatusContext = key ? { ...context } : {};
        currentStatusRaw = resolved;
        queueMicrotask(() => {
            suppressStatusObserver = false;
        });
    }

    setStatus('initializing', managerMessages.status.initializing);

    function clearConfigPanel() {
        currentPanelKey = null;
        currentPanelContext = {};
        currentPanelFallbackHtml = '';
        currentPanelSummaryFallback = '';
        if (configStatusBar) {
            configStatusBar.innerHTML = '';
        }
    }

    function renderConfigPanel() {
        if (!configStatusBar) return;

        if (!currentPanelKey) {
            configStatusBar.innerHTML = '';
            return;
        }

        if (currentPanelKey === 'importSummary') {
            const panelMessages = managerMessages.panel?.importSummary;
            if (panelMessages) {
                const panelContext = enhanceContextForKey(currentPanelKey, currentPanelContext);
                const summaryTemplate = managerMessages.status?.importSummary;
                const summaryMessage = summaryTemplate
                    ? formatTemplate(summaryTemplate, panelContext)
                    : currentPanelSummaryFallback;
                const title = panelMessages.title || '';
                const descriptionTemplate = panelMessages.description || '{{summary}}';
                const description = formatTemplate(descriptionTemplate, {
                    ...panelContext,
                    summary: summaryMessage,
                });
                const reopenLabel = panelMessages.reopen || '';
                configStatusBar.innerHTML = `
            <div class="flex justify-between items-start">
                <div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-3 rounded-md shadow-md flex-grow" role="alert">
                    <p class="font-bold">${title}</p>
                    <p class="text-sm">${description}</p>
                </div>
                <button id="showConfigButton" class="ml-4 mt-1 bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out whitespace-nowrap">
                    ${reopenLabel}
                </button>
            </div>
        `;
            } else {
                configStatusBar.innerHTML = currentPanelFallbackHtml;
            }
        } else {
            configStatusBar.innerHTML = currentPanelFallbackHtml;
        }

        const reopenButton = document.getElementById('showConfigButton');
        if (reopenButton) {
            reopenButton.addEventListener('click', () => {
                configFormContainer.classList.remove('hidden-form');
                clearConfigPanel();
            });
        }
    }

    function updateConfigPanel(key, fallbackHtml = '', context = {}, options = {}) {
        currentPanelKey = key;
        currentPanelContext = { ...context };
        currentPanelFallbackHtml = fallbackHtml;
        currentPanelSummaryFallback = options.summaryFallback || '';
        renderConfigPanel();
    }

    function applyLanguage(locale, { notify = true } = {}) {
        currentLocale = typeof locale === 'string' ? locale : DEFAULT_LOCALE;
        managerMessages = getManagerMessages(currentLocale);
        document.documentElement.lang = currentLocale;
        document.documentElement.dir = getDirection(currentLocale);
        document.title = managerMessages.documentTitle;

        if (managerTitleSpan) {
            managerTitleSpan.textContent = managerMessages.headerTitle;
        }

        if (managerBadge) {
            managerBadge.textContent = `(${managerMessages.badge})`;
        }

        if (managerSubtitle) {
            managerSubtitle.textContent = managerMessages.headerSubtitle;
        }

        if (statusMessage) {
            suppressStatusObserver = true;
            if (currentStatusKey && managerMessages.status[currentStatusKey]) {
                const template = managerMessages.status[currentStatusKey];
                const localizedContext = enhanceContextForKey(currentStatusKey, currentStatusContext);
                const translated = formatTemplate(template, localizedContext);
                statusMessage.textContent = translated;
                currentStatusRaw = translated;
            } else {
                statusMessage.textContent = currentStatusRaw;
            }
            queueMicrotask(() => {
                suppressStatusObserver = false;
            });
        }

        renderConfigPanel();

        if (notify && window.parent && typeof window.parent.postMessage === 'function') {
            window.parent.postMessage({ action: 'miniapp-language-applied', locale: currentLocale }, '*');
        }
    }

    function persistActiveMiniApps() {
        try {
            const payload = {
                updatedAt: new Date().toISOString(),
                items: Object.values(window.ACTIVE_MINIAPPS).map(app => {
                    const { isEdited, ...rest } = app;
                    return rest;
                }),
            };
            localStorage.setItem(STORAGE_KEYS.activeItems, JSON.stringify(payload));
        } catch (error) {
            console.warn('Não foi possível salvar o catálogo importado localmente.', error);
        }
    }

    function restoreActiveMiniAppsFromStorage() {
        let restoredCount = 0;
        try {
            const raw = localStorage.getItem(STORAGE_KEYS.activeItems);
            if (!raw) return 0;
            const parsed = JSON.parse(raw);
            const items = Array.isArray(parsed)
                ? parsed
                : Array.isArray(parsed?.items)
                    ? parsed.items
                    : [];

            window.ACTIVE_MINIAPPS = {};
            items.forEach(item => {
                if (!item || !item.id) return;
                window.ACTIVE_MINIAPPS[item.id] = {
                    ...item,
                    isEdited: false,
                };
                restoredCount += 1;
            });
        } catch (error) {
            console.warn('Não foi possível restaurar o catálogo salvo localmente.', error);
        }
        return restoredCount;
    }

    async function saveSheetId(sheetId) {
        try {
            localStorage.setItem(STORAGE_KEYS.sheetId, sheetId);
            localStorage.setItem(SHELL_SHEET_KEY, sheetId);
        } catch (error) {
            console.warn('Não foi possível salvar o ID da planilha localmente.', error);
        }
        return true;
    }

    async function trySignIn() { /* ... */ }
    function setupAuthListenerAndSignIn() { /* ... */ }

    function loadSavedSheetId() {
        let savedId = null;
        try {
            savedId = localStorage.getItem(STORAGE_KEYS.sheetId) || localStorage.getItem(SHELL_SHEET_KEY);
        } catch (error) {
            console.warn('Não foi possível ler o ID da planilha salvo.', error);
        }

        if (savedId && sheetUrlInput) {
            sheetUrlInput.value = savedId;
        }
        return savedId;
    }
    
    // --- LÓGICA DO CATÁLOGO E TABELA ---

    function buildCsvUrl(sheetIdOrUrl) {
        let sheetId = sheetIdOrUrl;
        let gid = '0';
        const idMatch = sheetIdOrUrl.match(/spreadsheets\/d\/([a-zA-Z0-9_-]+)/);
        if (idMatch && idMatch[1]) { sheetId = idMatch[1]; }
        const gidMatch = sheetIdOrUrl.match(/[?&]gid=(\d+)/);
        if (gidMatch && gidMatch[1]) { gid = gidMatch[1]; }
        if (!sheetId) return null;
        return { 
            sheetId,
            csvUrl: `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gid}`
        };
    }
    
    function parseCsv(csvText) {
        const lines = csvText.trim().split('\n');
        if (lines.length < 2) return [];
        
        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
        const data = lines.slice(1).map(line => {
            const values = line.split(',').map(d => d.trim().replace(/"/g, ''));
            const item = {};
            headers.forEach((header, index) => {
                item[header] = values[index] ? values[index].replace(/^"|"$/g, '') : '';
            });
            // Adiciona a propriedade 'selected' e define como true por padrão
            item.selected = true; 
            return item;
        }).filter(item => item.id && item.name); // MiniApps devem ter ID e Nome
        
        return data;
    }
    
    // Mapeamento dos Headers de Dados para Chaves (Usado nas duas seções)
    const DATA_HEADERS_MAP = [
        { id: 'id', name: 'ID', editable: false },
        { id: 'name', name: 'Nome', editable: true },
        { id: 'status', name: 'Status', editable: true },
        { id: 'category', name: 'Categoria', editable: true },
        { id: 'lastImport', name: 'Última Carga', editable: false } // Esta chave armazena o tempo de importação do servidor
    ];
    // Chaves de dados para ordenação (excluindo a coluna 'Selecionar' e 'Ações')
    const SORTABLE_KEYS = DATA_HEADERS_MAP.map(h => h.id).filter(key => key !== 'lastImport'); // 'lastImport' é dado do servidor, não da planilha CSV

    // Headers completos para a Seção 2 (Seleção) - Inclui a data do SERVIDOR
    const PREVIEW_HEADERS_CONFIG = [
        { id: 'select', name: 'Selecionar' },
        ...DATA_HEADERS_MAP.filter(h => h.id !== 'lastImport'), // Dados da planilha
        { id: 'serverLastImport', name: 'Última Carga (no Servidor)', key: 'lastImport' } // Dado do servidor para comparação
    ];

    // Headers completos para a Seção 3 (Ativa) com chaves para ordenação
    const ACTIVE_HEADERS_CONFIG = [
        ...DATA_HEADERS_MAP, 
        { id: 'actions', name: 'Ações', editable: false }
    ];

    // Função genérica de ordenação
    function sortData(data, sortState) {
        if (data.length === 0) return data;

        const key = sortState.key;
        const direction = sortState.direction === 'asc' ? 1 : -1;
        
        // A chave 'serverLastImport' na Seção 2 se refere ao 'lastImport' no ACTIVE_MINIAPPS
        const actualKey = key === 'serverLastImport' ? 'lastImport' : key;
        
        data.sort((a, b) => {
            // Se estiver ordenando a Pré-Visualização pelo tempo no servidor
            const valA = (key === 'serverLastImport' ? window.ACTIVE_MINIAPPS[a.id]?.lastImport : a[actualKey]) || '';
            const valB = (key === 'serverLastImport' ? window.ACTIVE_MINIAPPS[b.id]?.lastImport : b[actualKey]) || '';
            
            if (valA < valB) return -1 * direction;
            if (valA > valB) return 1 * direction;
            return 0;
        });
        
        return data;
    }

    // Função de Ordenação da Tabela de Pré-Visualização (Passo 2)
    window.sortPreview = function(key) {
        if (previewSortState.key === key) {
            previewSortState.direction = previewSortState.direction === 'asc' ? 'desc' : 'asc';
        } else {
            previewSortState.key = key;
            previewSortState.direction = 'asc';
        }
        renderPreviewSelection(window.CATALOG_PREVIEW_DATA);
    }

    // Renderiza a tabela de Pré-visualização e Seleção (Passo 2)
    function renderPreviewSelection(data) {
        const hasData = data.length > 0;
        
        // Ordena os dados ANTES de renderizar
        if (hasData) {
            data = sortData(data, previewSortState);
        }

        let tableHtml = `
            <div class="flex gap-2 mb-3 ${hasData ? '' : 'hidden'}">
                <button id="selectAllButton" class="action-button bg-gray-200 hover:bg-gray-300 text-gray-800">Selecionar Todos</button>
                <button id="clearSelectionButton" class="action-button bg-gray-200 hover:bg-gray-300 text-gray-800">Limpar Seleção</button>
            </div>
            <div class="overflow-x-auto bg-white rounded-lg shadow border border-gray-200 preview-table-container">
                <table class="w-full">
                <thead><tr>
                ${PREVIEW_HEADERS_CONFIG.map(h => {
                    if (h.id === 'select') {
                        return `<th class="whitespace-nowrap">${h.name}</th>`;
                    }
                    
                    const isCurrentSort = previewSortState.key === h.id;
                    const arrow = isCurrentSort 
                        ? (previewSortState.direction === 'asc' ? '▲' : '▼') 
                        : '';
                        
                    return `<th class="sortable-th whitespace-nowrap" 
                                onclick="window.sortPreview('${h.id}')"
                                title="Ordenar por ${h.name}">
                                ${h.name} ${arrow}
                            </th>`;
                }).join('')}
                </tr></thead>
                <tbody>
        `;
        
        if (!hasData) {
            tableHtml += `
                <tr class="bg-gray-50">
                    <td colspan="${PREVIEW_HEADERS_CONFIG.length}" class="text-center italic text-gray-500 py-6">
                        Clique em "Testar e Visualizar" (Passo 2) para carregar os MiniApps.
                    </td>
                </tr>
            `;
        } else {
            data.forEach((app, index) => {
                const isDuplicate = !!window.ACTIVE_MINIAPPS[app.id];
                const serverImportTime = isDuplicate ? window.ACTIVE_MINIAPPS[app.id].lastImport : '-';
                const rowClass = app.selected ? 'selected' : '';
                const checkboxId = `chk-${app.id}`;
                
                // Texto que indica se é atualização ou novo item
                let statusLabel = '';
                if (isDuplicate) {
                    statusLabel = ' (Atualização)';
                } else if (app.selected) {
                    statusLabel = ' (Novo)';
                }
                

                tableHtml += `<tr id="row-${app.id}" class="${rowClass}">
                    <td class="text-center">
                        <input type="checkbox" id="${checkboxId}" 
                            data-appid="${app.id}" 
                            ${app.selected ? 'checked' : ''} 
                            onchange="window.toggleRowSelection('${app.id}', this.checked)"
                            class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                        <label for="${checkboxId}" class="ml-2 text-xs">${statusLabel}</label>
                    </td>
                    <td title="${app.id}">${app.id}</td>
                    <td title="${app.name}">${app.name}</td>
                    <td title="${app.status}">${app.status || 'N/A'}</td>
                    <td title="${app.category}">${app.category || 'N/A'}</td>
                    <td class="text-sm italic text-gray-600">${serverImportTime}</td>
                </tr>`;
            });
        }
        
        tableHtml += '</tbody></table></div>';
        
        previewContainer.innerHTML = tableHtml;

        if (hasData) {
            // Adiciona listeners para os botões de seleção global
            document.getElementById('selectAllButton').addEventListener('click', () => {
                window.toggleAllSelection(true);
            });
            document.getElementById('clearSelectionButton').addEventListener('click', () => {
                window.toggleAllSelection(false);
            });
        }
    }

    // Alterna a seleção de uma linha individualmente
    window.toggleRowSelection = function(appId, isChecked) {
        const index = window.CATALOG_PREVIEW_DATA.findIndex(app => app.id === appId);
        if (index > -1) {
            window.CATALOG_PREVIEW_DATA[index].selected = isChecked;
            const row = document.getElementById(`row-${appId}`);
            if (row) {
                row.classList.toggle('selected', isChecked);
            }
        }
    }

    // Alterna a seleção de todos os itens
    window.toggleAllSelection = function(select) {
        window.CATALOG_PREVIEW_DATA.forEach(app => {
            app.selected = select;
            const checkbox = document.getElementById(`chk-${app.id}`);
            if (checkbox) {
                checkbox.checked = select;
                const row = document.getElementById(`row-${app.id}`);
                if (row) {
                    row.classList.toggle('selected', select);
                }
            }
        });
    }

    // --------------------------------------------------------------------------------------------------
    // NOVAS FUNÇÕES DE EDIÇÃO INLINE (SEÇÃO 3)
    // --------------------------------------------------------------------------------------------------

    // Marca a célula como editada e atualiza o objeto no ACTIVE_MINIAPPS
    window.handleCellInput = function(appId, key, element) {
        const app = window.ACTIVE_MINIAPPS[appId];
        if (!app) return;

        const newValue = element.textContent.trim();
        
        // Verifica se houve alteração real
        if (app[key] !== newValue) {
            app[key] = newValue;
            app.isEdited = true; 
            element.classList.add('data-edited');
        } else if (app.isEdited) {
            // Se o valor voltou ao original, verificamos se a edição deve ser removida
            // Para simplificar, neste teste, manteremos a flag isEdited, mas um sistema real faria uma comparação mais profunda.
            // Para nosso propósito, apenas adicionamos/removemos a classe visual.
            if (element.classList.contains('data-edited')) {
                // Se o valor de uma célula voltou, mas outras ainda podem estar editadas
                // Chamamos a função para re-renderizar a linha e atualizar o estado visual
                // renderActiveSummary() fará isso, mas para fins de performance, vamos apenas checar as classes.
            }
        }
        
        // Re-renderiza a tabela para garantir que o botão "Salvar Edições" apareça/suma
        renderActiveSummary();
    }
    
    // Simula a persistência dos dados editados
    window.saveEditedData = function(appId) {
        const app = window.ACTIVE_MINIAPPS[appId];
        if (!app || !app.isEdited) return;

        // Simula o salvamento no banco de dados
        console.log(`[PERSISTÊNCIA SIMULADA] Salvando dados atualizados para ID: ${appId}`, app);

        // Remove a flag de edição
        app.isEdited = false;

        // Atualiza o tempo de última carga para indicar a mudança
        app.lastImport = new Date().toLocaleTimeString('pt-BR') + ' (Editado)';

        persistActiveMiniApps();

        setStatus('miniappSaveSuccess', `MiniApp "${app.name}" (ID: ${appId}) teve suas edições salvas com sucesso no catálogo.`, {
            name: app.name,
            id: appId,
        });

        // Re-renderiza para limpar o estilo de edição
        renderActiveSummary();
    }

    // --------------------------------------------------------------------------------------------------
    
    // Manipulador de Ações (Atualização/Exclusão)
    window.handleMiniAppAction = function(action, appId) {
        const app = window.ACTIVE_MINIAPPS[appId];
        if (!app) return console.error(`MiniApp ID ${appId} não encontrado.`);

        switch (action) {
            case 'update':
                app.lastImport = new Date().toLocaleTimeString('pt-BR') + ' (Forçado)';
                persistActiveMiniApps();
                renderActiveSummary();
                setStatus('miniappForceUpdate', `MiniApp "${app.name}" (ID: ${appId}) forçado a atualizar (simulação).`, {
                    name: app.name,
                    id: appId,
                });
                break;
            case 'delete':
                delete window.ACTIVE_MINIAPPS[appId];
                persistActiveMiniApps();
                renderActiveSummary();
                setStatus('miniappRemoved', `MiniApp "${app.name}" (ID: ${appId}) excluído da lista ativa.`, {
                    name: app.name,
                    id: appId,
                });
                break;
            default:
                console.warn(`Ação desconhecida: ${action}`);
        }
    }
    
    // Função de Ordenação da Tabela de Resumo (Passo 3)
    window.sortSummary = function(key) {
        if (summarySortState.key === key) {
            summarySortState.direction = summarySortState.direction === 'asc' ? 'desc' : 'asc';
        } else {
            summarySortState.key = key;
            summarySortState.direction = 'asc';
        }
        renderActiveSummary();
    }

    // Renderiza o resumo ativo na tabela (Passo 3)
    function renderActiveSummary() {
        let activeAppsArray = Object.values(window.ACTIVE_MINIAPPS);
        
        const headers = ACTIVE_HEADERS_CONFIG;

        // Aplica a ordenação SOMENTE se houver dados
        if (activeAppsArray.length > 0) {
            activeAppsArray = sortData(activeAppsArray, summarySortState);
        }

        let tableHtml = `<h3 class="text-lg font-semibold mb-3 text-gray-800">3. Catálogo Ativo (Edição Inline) - ${activeAppsArray.length} MiniApps</h3>`;
        tableHtml += '<div class="overflow-x-auto bg-white rounded-lg shadow border border-gray-200"><table class="summary-table">';
        
        // Cabeçalho da Tabela com Função de Sorteio
        tableHtml += '<thead><tr>' + headers.map(h => {
            if (h.id === 'actions') return `<th>${h.name}</th>`;
            
            const isCurrentSort = summarySortState.key === h.id;
            const arrow = isCurrentSort 
                ? (summarySortState.direction === 'asc' ? '▲' : '▼') 
                : '';
                
            // A Seção 3 permite ordenação
            return `<th class="sortable-th" onclick="window.sortSummary('${h.id}')" title="Ordenar por ${h.name}">${h.name} ${arrow}</th>`;
        }).join('') + '</tr></thead>';
        
        // Linhas de dados
        tableHtml += '<tbody>';
        
        if (activeAppsArray.length === 0) {
            tableHtml += `
                <tr class="bg-gray-50">
                    <td colspan="${headers.length}" class="text-center italic text-gray-500">
                        Nenhum MiniApp ativo na lista. Importe no Passo 1 e 2.
                    </td>
                </tr>
            `;
        } else {
            activeAppsArray.forEach(app => {
                let statusColor = 'bg-gray-100 text-gray-800';
                if (app.status && app.status.toLowerCase() === 'ativo') {
                    statusColor = 'bg-green-100 text-green-800';
                } else if (app.status && app.status.toLowerCase() === 'beta') {
                    statusColor = 'bg-yellow-100 text-yellow-800';
                }
                
                // Mapeia os dados para as células
                const cellsHtml = ACTIVE_HEADERS_CONFIG.map(header => {
                    const key = header.id;
                    const value = app[key] || 'N/A';
                    
                    if (key === 'actions') {
                        const saveButton = app.isEdited 
                            ? `<button onclick="window.saveEditedData('${app.id}')" class="action-button bg-orange-500 hover:bg-orange-600 text-white font-bold">Salvar Edições</button>`
                            : '';
                            
                        return `<td>
                            ${saveButton}
                            <button onclick="window.handleMiniAppAction('update', '${app.id}')" class="action-button bg-blue-500 hover:bg-blue-600 text-white" title="Simular atualização de planilha">Atualizar</button>
                            <button onclick="window.handleMiniAppAction('delete', '${app.id}')" class="action-button bg-red-500 hover:bg-red-600 text-white">Excluir</button>
                        </td>`;
                    }
                    
                    // Células Editáveis
                    if (header.editable) {
                        const isEditedClass = app.isEdited ? 'data-edited' : '';
                        
                        return `<td contenteditable="true" 
                                    class="editable-cell ${isEditedClass}"
                                    title="${value}"
                                    data-appid="${app.id}"
                                    data-key="${key}"
                                    onblur="window.handleCellInput('${app.id}', '${key}', this)"
                                    onkeydown="if(event.key === 'Enter') { event.preventDefault(); this.blur(); }">
                                    ${value}
                                </td>`;
                    }
                    
                    // Células Estáticas (ID, Last Import)
                    if (key === 'status') {
                        return `<td title="${value}"><span class="px-2 py-1 inline-flex text-xs leading-5 font-semibold rounded-full ${statusColor}">${value}</span></td>`;
                    }
                    
                    if (key === 'lastImport') {
                        return `<td class="text-sm italic text-gray-600" title="${value}">${value}</td>`;
                    }
                    
                    // ID
                    return `<td title="${value}">${value}</td>`;
                }).join('');


                tableHtml += `<tr>${cellsHtml}</tr>`;
            });
        }
        tableHtml += '</tbody></table></div>';
        
        summaryContainer.innerHTML = tableHtml;
    }
    
    // Função que garante que a tabela de pré-visualização seja renderizada vazia no início
    function renderEmptyPreview() {
        // Renderiza a estrutura da tabela vazia
        window.CATALOG_PREVIEW_DATA = []; // Garante que a lista de dados esteja vazia
        renderPreviewSelection([]);
    }

    // Função de Pré-visualização (Busca os dados e inicia a seleção)
    window.previewCatalog = async function() {
        const sheetIdOrUrl = sheetUrlInput.value.trim();
        const result = buildCsvUrl(sheetIdOrUrl);
        
        // Limpa a lista anterior
        window.CATALOG_PREVIEW_DATA = [];
        importButton.disabled = true;

        if (!result) {
            setStatus('invalidSheet', 'Erro: URL ou ID da Planilha inválido. Verifique o formato.');
            renderEmptyPreview();
            return;
        }

        const { sheetId, csvUrl } = result;
        const gid = result.csvUrl.match(/[?&]gid=(\d+)/)?.[1] || '0';
        setStatus('fetchingSheet', `Buscando dados da planilha do ID: ${sheetId} (GID: ${gid})...`, { sheetId, gid });
        
        try {
            const response = await fetch(csvUrl, { method: 'GET', mode: 'cors', cache: 'no-cache', credentials: 'omit' }); 
            
            if (!response.ok) {
                const errorText = await response.text().catch(() => response.statusText);
                throw new Error(`Erro HTTP: ${response.status}. Detalhe: ${errorText}. Certifique-se de que a planilha está pública.`);
            }
            
            const csvText = await response.text();
            
            // Armazena os dados completos na variável global para seleção
            const allData = parseCsv(csvText);
            window.CATALOG_PREVIEW_DATA = allData;
            
            if (allData.length === 0) {
                setStatus(
                    'noValidMiniapps',
                    "Planilha encontrada, mas sem MiniApps válidos (verifique se as colunas 'id' e 'name' existem).",
                );
                 renderEmptyPreview();
                 return;
            }

            // Renderiza a nova tabela com checkboxes
            renderPreviewSelection(allData);
            
            setStatus(
                'previewReady',
                `Pré-visualização OK! ${allData.length} MiniApps encontrados. Selecione os itens e clique em "Importar e Carregar".`,
                { count: allData.length },
            );
            importButton.disabled = false; 

        } catch (error) {
            console.error("Erro ao pré-visualizar o catálogo:", error);
            setStatus(
                'loadError',
                `Erro ao carregar: Verifique o link/ID e o status de compartilhamento. O erro foi: ${error.message}`,
                { message: error.message },
            );
            importButton.disabled = true;
            renderEmptyPreview();
        }
    }

    // Função de Importação Final (processa apenas os MiniApps selecionados)
    window.importCatalog = function() {
        const sheetIdOrUrl = sheetUrlInput.value.trim();
        const result = buildCsvUrl(sheetIdOrUrl);
        
        // Filtra APENAS os dados que foram selecionados na etapa 2
        const newData = window.CATALOG_PREVIEW_DATA.filter(app => app.selected);

        if (!result || newData.length === 0) {
        setStatus(
            'noSelection',
            "Erro: Nenhum MiniApp selecionado para importar. Primeiro, clique em 'Testar e Visualizar' com um link válido e selecione os MiniApps.",
        );
            return;
        }
        
        if (result.sheetId) {
            // Persiste o ID da planilha mesmo sem Firebase para manter a experiência offline.
            saveSheetId(result.sheetId);
        }
        
        // Esconde o formulário
        configFormContainer.classList.add('hidden-form');
        
        // Limpa a pré-visualização (Passo 2)
        renderEmptyPreview();
    setStatus('importing', 'Importando e Mesclando MiniApps Ativos...');
        
        let newAppsCount = 0;
        let updateAppsCount = 0;

        // Mescla os dados selecionados com os dados ativos existentes (Passo 3)
        newData.forEach(app => {
            if (app.id) {
                if (window.ACTIVE_MINIAPPS[app.id]) {
                    updateAppsCount++;
                } else {
                    newAppsCount++;
                }
                
                // Sobrescreve/adiciona o objeto, incluindo a data/hora da última importação
                // Remove a flag temporária 'selected'
                const { selected, ...appData } = app;
                
                window.ACTIVE_MINIAPPS[app.id] = {
                    ...appData,
                    // Garante que o MiniApp ativo no servidor receba a hora atual como última carga
                    lastImport: new Date().toLocaleTimeString('pt-BR'),
                    isEdited: false // Garante que a flag de edição seja limpa
                };
            }
        });

        persistActiveMiniApps();

        // Renderiza a tabela de resumo ativa (Passo 3)
        renderActiveSummary();

        const totalApps = Object.keys(window.ACTIVE_MINIAPPS).length;
        const successMessage = `Importação Completa! ${newAppsCount} novos MiniApps adicionados e ${updateAppsCount} atualizados (de ${newData.length} selecionados). Total ativo: ${totalApps}.`;
        const summaryContext = {
            newCount: newAppsCount,
            updatedCount: updateAppsCount,
            selectedCount: newData.length,
            totalCount: totalApps,
            sectionNumber: '3',
        };
        const fallbackPanelHtml = `
            <div class="flex justify-between items-start">
                <div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-3 rounded-md shadow-md flex-grow" role="alert">
                    <p class="font-bold">Configuração Finalizada!</p>
                    <p class="text-sm">${successMessage} A lista gerenciável está na Seção 3, onde você pode editá-los diretamente.</p>
                </div>
                <button id="showConfigButton" class="ml-4 mt-1 bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out whitespace-nowrap">
                    Reabrir Configuração
                </button>
            </div>
        `;

        setStatus('importSummary', successMessage, summaryContext);
        updateConfigPanel('importSummary', fallbackPanelHtml, summaryContext, { summaryFallback: successMessage });

        testButton.disabled = false;
        importButton.disabled = true; // Desabilita até que um novo teste seja feito
    }
    
    window.addEventListener('message', (event) => {
        const { data } = event;
        if (!data || data.action !== 'shell-language') {
            return;
        }
        applyLanguage(data.locale);
    });

    applyLanguage(currentLocale, { notify: false });

    if (window.parent && typeof window.parent.postMessage === 'function') {
        window.parent.postMessage({ action: 'miniapp-language-ready' }, '*');
    }

    // --- INICIALIZAÇÃO E LISTENERS ---
    document.addEventListener('DOMContentLoaded', () => {
        importButton.disabled = true;

        const savedSheetId = loadSavedSheetId();
        const restoredCount = restoreActiveMiniAppsFromStorage();
        if (!firebaseInitialized && restoredCount > 0) {
            setStatus(
                'localRestored',
                `Catálogo local restaurado (${restoredCount} MiniApps ativos).`,
                { count: restoredCount },
            );
        }

        testButton.addEventListener('click', window.previewCatalog);
        importButton.addEventListener('click', window.importCatalog);

        sheetUrlInput.addEventListener('input', () => {
            importButton.disabled = true;
            const previewStep = managerMessages.steps?.preview || {};
            const stepLabel = previewStep.shortLabel || 'Testar e Visualizar';
            const stepNumber = previewStep.number || '2';
            setStatus(
                'linkChanged',
                "Link/ID alterado. Clique em 'Testar e Visualizar' (Passo 2).",
                { stepKey: 'preview', stepLabel, stepNumber },
            );
            clearConfigPanel();
            renderEmptyPreview(); // Garante que a seção 2 volte ao estado inicial
        });
        
        if (firebaseInitialized) {
            // setupAuthListenerAndSignIn();
        } else {
             //statusMessage.textContent = "Erro: Configuração do Firebase faltando. Persistência desativada.";
        }

        // Renderiza as tabelas vazias no carregamento
        renderEmptyPreview();
        renderActiveSummary();

        if (savedSheetId && restoredCount === 0) {
            const previewStep = managerMessages.steps?.preview || {};
            const stepLabel = previewStep.shortLabel || 'Testar e Visualizar';
            const stepNumber = previewStep.number || '2';
            setStatus(
                'sheetRestored',
                "ID da planilha recuperado. Clique em 'Testar e Visualizar' (Passo 2) para sincronizar.",
                { stepKey: 'preview', stepLabel, stepNumber },
            );
        }
    });
    
  </script>
  
</head>
<body>
  <div class="ma min-h-screen">
    <div class="wrap p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto">
      
      <!-- NOVO TÍTULO ADMINISTRATIVO NO TOPO -->
      <h1 id="managerHeading" class="text-3xl font-bold mb-4 text-gray-800">
        <span data-manager-title>Gestor de Catálogo de MiniApps</span>
        <span id="managerBadge" class="text-lg font-normal text-red-500 ml-2">(Acesso Admin)</span>
      </h1>
      <p id="managerSubtitle" class="text-gray-600 mb-6">Ferramenta completa para importar, validar e publicar o catálogo de MiniApps para todos os usuários.</p>
      
      <!-- Seção de Configuração da Planilha - Passo 1 -->
      <header id="config-header" class="bg-white shadow-md p-4 mb-8 rounded-lg">
        
        <!-- Contêiner da Barra de Status (Fica visível após ocultar) -->
        <div id="config-status-bar">
            <!-- Inicialmente vazio, preenchido após importação -->
        </div>

        <!-- Contêiner do Formulário e Entradas (Fica oculto ao "fechar") -->
        <div id="config-form-container">
            <h2 class="text-xl font-bold mb-3 text-gray-800">1. Configuração da Planilha Google</h2>
            <p class="text-sm text-gray-500 mb-4">Insira o link completo ou o ID da planilha de catálogo. Certifique-se de que ela está **compartilhada publicamente**.</p>
            
            <div class="flex flex-col md:flex-row gap-3">
              <input 
                type="text" 
                id="sheetUrlInput" 
                placeholder="Cole o link COMPLETO (com gid) ou o ID da Planilha Google" 
                class="flex-grow p-3 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm"
              />
              <button 
                id="testSheetButton" 
                class="bg-yellow-600 hover:bg-yellow-700 text-white font-semibold py-3 px-6 rounded-md shadow-md transition duration-150 ease-in-out w-full md:w-auto"
              >
                Testar e Visualizar (Passo 2)
              </button>
              <button 
                id="importCatalogButton" 
                disabled
                class="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-md shadow-md transition duration-150 ease-in-out w-full md:w-auto disabled:opacity-50 disabled:cursor-not-allowed"
                title="Este botão será ativado após a pré-visualização no Passo 2."
              >
                Importar e Carregar (Passo 3)
              </button>
            </div>
            <p id="status-message" class="mt-2 text-sm text-gray-500">Inicializando... Por favor, insira o link da planilha e clique em "Testar e Visualizar".</p>
        </div>
      </header>
      
      <!-- Seção de Seleção e Pré-Visualização - Passo 2 -->
      <section id="preview-section" class="mb-8">
          <h3 class="text-lg font-semibold mb-2 text-gray-800">2. Seleção de MiniApps para Importação (Pré-visualização e Filtro)</h3>
          <div id="preview-data-container">
              <!-- O conteúdo da pré-visualização e seleção é renderizado aqui -->
          </div>
      </section>
      
      <!-- SEÇÃO DE RESUMO E LISTA ATIVA - Passo 3 -->
      <section id="loaded-summary-section" class="mb-8">
          <div id="loaded-summary-container">
              <!-- A tabela de MiniApps ativos será renderizada aqui -->
          </div>
      </section>


      <!-- Seção do Catálogo (Removida para esta versão administrativa) -->
      
    </div>
  </div>
  <script>
  (function () {
    const root = document.querySelector('.ma');

    const applyTheme = (theme) => {
      const normalizedTheme = theme === 'dark' ? 'dark' : 'light';
      if (root) {
        if (normalizedTheme === 'dark') {
          root.setAttribute('data-theme', 'dark');
        } else {
          root.removeAttribute('data-theme');
        }
      }

      if (normalizedTheme === 'dark') {
        document.body.setAttribute('data-theme', 'dark');
      } else {
        document.body.removeAttribute('data-theme');
      }

      if (window.parent && typeof window.parent.postMessage === 'function') {
        window.parent.postMessage({ action: 'miniapp-theme-applied', theme: normalizedTheme }, '*');
      }
    };

    window.addEventListener('message', (event) => {
      const { data } = event;
      if (!data || data.action !== 'shell-theme') {
        return;
      }
      applyTheme(data.theme);
    });

    if (window.parent && typeof window.parent.postMessage === 'function') {
      window.parent.postMessage({ action: 'miniapp-theme-ready' }, '*');
    }
  }());
</script>
</body>
</html>
